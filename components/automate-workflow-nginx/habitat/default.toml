# The maximum accepted body size for a client request, as indicated by the
# Content-Length request header. When the maximum accepted body size is greater
# than this value, a 413 Request Entity Too Large error is returned.
client_max_body_size = "250m"

# The fully qualified domain name for the server. This should be set to the
# address at which people will be accessing the server.
server_name = "automate"

# Port used for http traffic
port = 10300

# Port used for SSL traffic
ssl_port = 10301

# # SSL protocols and ciphers

# These options provide the current best security with TSLv1
# ssl_protocols = "-ALL +TLSv1"
# ssl_ciphers = "RC4:!MD5"

# This might be necessary for auditors that want no MEDIUM security ciphers and
# don't understand BEAST attacks
# ssl_protocols = "-ALL +SSLv3 +TLSv1"
# ssl_ciphers = "HIGH:!MEDIUM:!LOW:!ADH:!kEDH:!aNULL:!eNULL:!EXP:!SSLv2:!SEED:!CAMELLIA:!PSK"

# Based off of the Mozilla recommended cipher suite
# https://mozilla.github.io/server-side-tls/ssl-config-generator/?server=nginx-1.8.1&openssl=1.0.1u&hsts=no&profile=modern
# NOTE: testssl.sh warns about Secure Renegotiation (CVE-2009-3555),
#       but this might be ok since it should only allow for renegotiating from one
#       of the allowed ciphers to another one.
# NOTE: AES256-GCM-SHA384 is not part of the Mozilla suite but has been added to
#       support AWS's classic ELB's. Without it the health checks will fail.
ssl_protocols = "TLSv1.2 TLSv1.3"
ssl_ciphers = "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:AES256-GCM-SHA384:!aNULL:!eNULL:!EXPORT"
ssl_certificate = "/hab/svc/automate-workflow-nginx/data/cert"
ssl_certificate_key = "/hab/svc/automate-workflow-nginx/data/key"
worker_connections = 1024
sendfile = "on"
tcp_nodelay = "on"
tcp_nopush = "on"
keepalive_timeout = 65

# Defaulting to off to avoid BREACH/CRIME attack exploits
[gzip]
enabled = "off"
comp_level = 2
http_version = "1.0"
proxied = "any"
types = [ "text/plain", "text/css",
  "application/x-javascript", "text/xml",
  "application/javascript", "application/xml",
  "application/xml+rss", "text/javascript",
  "application/json"
]

[mlsa]
accept = false

[log]
level = "info"

# Options for Kibana
# [kibana]
# # Whether or not Kibana is enabled. If this is false, /kibana will be a 404.
# enable = true
# # If this is false, anyone can access /kibana without restrictions.
# enable_auth = true
