syntax = "proto3";

package chef.automate.api.applications;
option go_package = "github.com/chef/automate/api/external/applications";

import "google/api/annotations.proto";

// TODO @afiune Move or re-create the common messages inside the api/ folder
import "api/external/common/version/version.proto";

// for option (chef.automate.api.policy)
import "components/automate-grpc/protoc-gen-policy/api/annotations.proto";
// for option (chef.automate.api.iam.policy)
import "components/automate-grpc/protoc-gen-policy/iam/annotations.proto";
// for sorting and pagination
import "api/external/common/query/parameters.proto";

service ApplicationsService {
  rpc GetServiceGroups(ServiceGroupsReq) returns (ServiceGroups) {
    option (google.api.http).get = "/beta/applications/service-groups";
    // TODO (dan, 2/2019): need to replace this once we have resources and such
    // created in the auth system
    option (chef.automate.api.policy) = {
      resource: "nodes"
      action: "list"
    };
    option (chef.automate.api.iam.policy) = {
      resource: "infra:nodes"
      action: "infra:nodes:list"
    };
  };
  rpc GetServiceGroupsHealthCounts(ServiceGroupsHealthCountsReq) returns (HealthCounts) {
    // TODO (afiune, 3/2019): need to replace this once we have resources and such
    // created in the auth system
    option (google.api.http).get = "/beta/applications/service_groups_health_counts";
    option (chef.automate.api.policy).resource = "nodes";
    option (chef.automate.api.policy).action = "list";
    option (chef.automate.api.iam.policy).resource = "infra:nodes";
    option (chef.automate.api.iam.policy).action = "infra:nodes:list";
  };
  rpc GetServices(ServicesReq) returns (ServicesRes) {
    // TODO (afiune, 4/2019): need to replace this once we have resources and such
    // created in the auth system
    option (google.api.http).get = "/beta/applications/services";
    option (chef.automate.api.policy).resource = "nodes";
    option (chef.automate.api.policy).action = "list";
    option (chef.automate.api.iam.policy).resource = "infra:nodes";
    option (chef.automate.api.iam.policy).action = "infra:nodes:list";
  };

  rpc GetServicesBySG(ServicesBySGReq) returns (ServicesBySGRes) {
    // TODO (afiune, 4/2019): need to replace this once we have resources and such
    // created in the auth system
    option (google.api.http).get = "/beta/applications/service-groups/{service_group_id}";
    option (chef.automate.api.policy).resource = "nodes";
    option (chef.automate.api.policy).action = "list";
    option (chef.automate.api.iam.policy).resource = "infra:nodes";
    option (chef.automate.api.iam.policy).action = "infra:nodes:list";
  };
  rpc GetVersion (common.version.VersionInfoRequest) returns (common.version.VersionInfo) {
    option (google.api.http).get = "/beta/applications/version";
    option (chef.automate.api.policy).resource = "service_info:version";
    option (chef.automate.api.policy).action = "read";
    option (chef.automate.api.iam.policy).resource = "system:service:version";
    option (chef.automate.api.iam.policy).action = "system:serviceVersion:get";
  };
}

message ServicesReq {
  repeated string filter = 1;
  common.query.Pagination pagination = 2;
  common.query.Sorting sorting = 3;
}

message ServicesBySGReq {
  int32 service_group_id = 1;
  common.query.Pagination pagination = 2;
  common.query.Sorting sorting = 3;
  string health = 4;
}

message ServicesBySGRes {
  string group = 1;
  repeated Service services = 2;
}

message ServicesRes {
  repeated Service services = 1;
}

message Service {
  string supervisor_id = 1;
  string release = 2;
  string group = 3;
  HealthStatus health_check = 4;
  ServiceStatus status = 5;
  string application = 6;
  string environment = 7;
  string fqdn = 8;
}

message ServiceGroupsHealthCountsReq {}
message ServiceGroupsReq {
  repeated string filter = 1;
  common.query.Pagination pagination = 2;
  common.query.Sorting sorting = 3;
}

// A service group message is the representation of one single service group that
// is internally generated by aggregating all the services
message ServiceGroup {
  string name = 1;
  // This field is the full package identifier combined in a single string like:
  // Example: core/redis/0.1.0/8743278934278923
  string release = 2;
  HealthStatus status = 3;

  // The health_percentage can be a number between 0-100
  int32 health_percentage = 4;

  HealthCounts services_health_counts = 5;
  string id = 6;
}

message HealthCounts {
  int32 total = 1;
  int32 ok = 2;
  int32 warning = 3;
  int32 critical = 4;
  int32 unknown = 5;
}

// A HabService message is the representation of one single service in habitat
message HabService {
  // We currently don't know if habitat has a unique identifier so for now
  // we will generate this id internally inside our service
  //
  // UPDATE: @afiune a service itself doesn't have an ID but instead it composed
  // by something called "full qualified identifier" (FQID) that is the combination
  // of the package origin, name, version and timestamp (and in the future also the
  // target, which is not yet part of the FQID in habitat). Though, for us to
  // distinguish a service that is running in multiple instances, we will need the
  // Supervisor ID plus the origin and package name.
  //
  // That means that for us a unique Service is identified by:
  //
  // * supervisor_id
  // * pkg_origin
  // * pkg_name
  //
  // Not these two fields since they can change on every pkg release
  // * pkg_version
  // * pkg_release
  //
  // Potential considerations:
  // * package target (package built for linux/windows/etc)
  // * Do NOT use FQID to describe this message
  string supervisor_id = 1;
  string group = 2;
  PackageIdent pkg_ident = 3;
  HealthStatus health_check = 4;
  ServiceStatus status = 5;

  // @afiune Proposal to start receiving informatino about the hab-ring
  /*repeated string members = 6;*/

  // @afiune These information will come as tags, once we have the data structure
  // we will have to redo these fields, for now we will assume they will be provided
  // as follows
  string application = 7;
  string environment = 8;

  // @afiune We need to figure out how the fqdn will be provided
  string fqdn = 9;
}

// The package indentifier of a service is unique and is the combination
// of origin/name/version/release
//
// Example: core/redis/0.1.0/8743278934278923
message PackageIdent {
  string origin = 1;
  string name = 2;
  string version = 3;
  string release = 4;
}

message ServiceGroups  {
  repeated ServiceGroup service_groups = 1;
}

// The ServiceStatus enum describes the status of the service
// @afiune have we defined these states somewhere?
enum ServiceStatus {
  RUNNING = 0;
  INITIALIZING = 1;
  DEPLOYING = 2;
  DOWN = 3;
}

// The HealthStatus enum matches the habitat implementation for health-check status:
// => https://www.habitat.sh/docs/reference/#health-check
enum HealthStatus {
  OK = 0;
  WARNING = 1;
  CRITICAL = 2;
  UNKNOWN = 3;
}
