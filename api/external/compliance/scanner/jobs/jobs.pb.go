// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/external/compliance/scanner/jobs/jobs.proto

package jobs

import (
	context "context"
	fmt "fmt"
	query "github.com/chef/automate/api/external/common/query"
	_ "github.com/chef/automate/components/automate-grpc/protoc-gen-policy/iam"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Return the results in ascending or descending order.
type Query_OrderType int32

const (
	Query_ASC  Query_OrderType = 0
	Query_DESC Query_OrderType = 1
)

var Query_OrderType_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}

var Query_OrderType_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x Query_OrderType) String() string {
	return proto.EnumName(Query_OrderType_name, int32(x))
}

func (Query_OrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{2, 0}
}

type RerunResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RerunResponse) Reset()         { *m = RerunResponse{} }
func (m *RerunResponse) String() string { return proto.CompactTextString(m) }
func (*RerunResponse) ProtoMessage()    {}
func (*RerunResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{0}
}

func (m *RerunResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RerunResponse.Unmarshal(m, b)
}
func (m *RerunResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RerunResponse.Marshal(b, m, deterministic)
}
func (m *RerunResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RerunResponse.Merge(m, src)
}
func (m *RerunResponse) XXX_Size() int {
	return xxx_messageInfo_RerunResponse.Size(m)
}
func (m *RerunResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RerunResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RerunResponse proto.InternalMessageInfo

type Id struct {
	// Unique ID (UUID) assigned to object.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name of object.
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Id) Reset()         { *m = Id{} }
func (m *Id) String() string { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()    {}
func (*Id) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{1}
}

func (m *Id) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Id.Unmarshal(m, b)
}
func (m *Id) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Id.Marshal(b, m, deterministic)
}
func (m *Id) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Id.Merge(m, src)
}
func (m *Id) XXX_Size() int {
	return xxx_messageInfo_Id.Size(m)
}
func (m *Id) XXX_DiscardUnknown() {
	xxx_messageInfo_Id.DiscardUnknown(m)
}

var xxx_messageInfo_Id proto.InternalMessageInfo

func (m *Id) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Id) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Query struct {
	// Use filters to limit the set of items returned.
	Filters []*query.Filter `protobuf:"bytes,20,rep,name=filters,proto3" json:"filters,omitempty"`
	Order   Query_OrderType `protobuf:"varint,21,opt,name=order,proto3,enum=chef.automate.api.compliance.scanner.jobs.v1.Query_OrderType" json:"order,omitempty"`
	// Sort the results on a specific field.
	Sort string `protobuf:"bytes,22,opt,name=sort,proto3" json:"sort,omitempty"`
	// The number of result pages to return.
	Page int32 `protobuf:"varint,23,opt,name=page,proto3" json:"page,omitempty"`
	// The number of results on each page.
	PerPage              int32    `protobuf:"varint,24,opt,name=per_page,json=perPage,proto3" json:"per_page,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{2}
}

func (m *Query) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Query.Unmarshal(m, b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Query.Marshal(b, m, deterministic)
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return xxx_messageInfo_Query.Size(m)
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetFilters() []*query.Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *Query) GetOrder() Query_OrderType {
	if m != nil {
		return m.Order
	}
	return Query_ASC
}

func (m *Query) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

func (m *Query) GetPage() int32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *Query) GetPerPage() int32 {
	if m != nil {
		return m.PerPage
	}
	return 0
}

type ManagerFilter struct {
	// Unique ID of a node manager.
	ManagerId string `protobuf:"bytes,1,opt,name=manager_id,json=managerId,proto3" json:"manager_id,omitempty"`
	// Use filters to limit the set of items returned.
	Filters              []*query.Filter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ManagerFilter) Reset()         { *m = ManagerFilter{} }
func (m *ManagerFilter) String() string { return proto.CompactTextString(m) }
func (*ManagerFilter) ProtoMessage()    {}
func (*ManagerFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{3}
}

func (m *ManagerFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ManagerFilter.Unmarshal(m, b)
}
func (m *ManagerFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ManagerFilter.Marshal(b, m, deterministic)
}
func (m *ManagerFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManagerFilter.Merge(m, src)
}
func (m *ManagerFilter) XXX_Size() int {
	return xxx_messageInfo_ManagerFilter.Size(m)
}
func (m *ManagerFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ManagerFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ManagerFilter proto.InternalMessageInfo

func (m *ManagerFilter) GetManagerId() string {
	if m != nil {
		return m.ManagerId
	}
	return ""
}

func (m *ManagerFilter) GetFilters() []*query.Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type Job struct {
	// Unique ID (UUID) of the scan job.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// User-specified name of the scan job.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Determines the type of Chef InSpec run, `detect` or `exec`.
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// Desired timeout (in seconds) for the scan job execution. Default: 7200 for exec jobs, 600 for detect jobs.
	Timeout int32 `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// Tags to assign to the scan job.
	Tags []*query.Kv `protobuf:"bytes,20,rep,name=tags,proto3" json:"tags,omitempty"`
	// Start time of the scan job, assigned by the service.
	StartTime *timestamp.Timestamp `protobuf:"bytes,21,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time of the scan job, assigned by the service.
	EndTime *timestamp.Timestamp `protobuf:"bytes,22,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Status of the scan job, assigned by the service.
	Status string `protobuf:"bytes,23,opt,name=status,proto3" json:"status,omitempty"`
	// Number of times to retry the scan job. Default: 3.
	Retries int32 `protobuf:"varint,26,opt,name=retries,proto3" json:"retries,omitempty"`
	// Number of retries left, assigned by the service.
	RetriesLeft int32 `protobuf:"varint,27,opt,name=retries_left,json=retriesLeft,proto3" json:"retries_left,omitempty"`
	// Results of the scan job, including a report ID if one was generated.
	Results []*ResultsRow `protobuf:"bytes,28,rep,name=results,proto3" json:"results,omitempty"`
	// List of node IDs to associate with the scan job.
	Nodes []string `protobuf:"bytes,100,rep,name=nodes,proto3" json:"nodes,omitempty"`
	// List of profiles to execute as part of the scan job.
	Profiles []string `protobuf:"bytes,101,rep,name=profiles,proto3" json:"profiles,omitempty"`
	// Count of nodes to be scanned as part of the job, assigned by the service.
	NodeCount int32 `protobuf:"varint,102,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Count of profiles to be executed as part of the job.
	ProfileCount int32 `protobuf:"varint,103,opt,name=profile_count,json=profileCount,proto3" json:"profile_count,omitempty"`
	// Set of node manager IDs and filters to associate with the scan job.
	NodeSelectors []*ManagerFilter `protobuf:"bytes,104,rep,name=node_selectors,json=nodeSelectors,proto3" json:"node_selectors,omitempty"`
	// Next scheduled scan execution time.
	ScheduledTime *timestamp.Timestamp `protobuf:"bytes,105,opt,name=scheduled_time,json=scheduledTime,proto3" json:"scheduled_time,omitempty"`
	// Recurrence schedule string for the job.
	Recurrence string `protobuf:"bytes,106,opt,name=recurrence,proto3" json:"recurrence,omitempty"`
	// ID of parent job to associate with the job, if any.
	ParentId string `protobuf:"bytes,107,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// Count of scans executed by the job.
	JobCount int32 `protobuf:"varint,108,opt,name=job_count,json=jobCount,proto3" json:"job_count,omitempty"`
	// Boolean used to denote the job has been marked as "deleted" by the user.
	Deleted              bool     `protobuf:"varint,109,opt,name=deleted,proto3" json:"deleted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{4}
}

func (m *Job) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Job.Unmarshal(m, b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Job.Marshal(b, m, deterministic)
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return xxx_messageInfo_Job.Size(m)
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Job) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Job) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Job) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *Job) GetTags() []*query.Kv {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Job) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *Job) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Job) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Job) GetRetries() int32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *Job) GetRetriesLeft() int32 {
	if m != nil {
		return m.RetriesLeft
	}
	return 0
}

func (m *Job) GetResults() []*ResultsRow {
	if m != nil {
		return m.Results
	}
	return nil
}

func (m *Job) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *Job) GetProfiles() []string {
	if m != nil {
		return m.Profiles
	}
	return nil
}

func (m *Job) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *Job) GetProfileCount() int32 {
	if m != nil {
		return m.ProfileCount
	}
	return 0
}

func (m *Job) GetNodeSelectors() []*ManagerFilter {
	if m != nil {
		return m.NodeSelectors
	}
	return nil
}

func (m *Job) GetScheduledTime() *timestamp.Timestamp {
	if m != nil {
		return m.ScheduledTime
	}
	return nil
}

func (m *Job) GetRecurrence() string {
	if m != nil {
		return m.Recurrence
	}
	return ""
}

func (m *Job) GetParentId() string {
	if m != nil {
		return m.ParentId
	}
	return ""
}

func (m *Job) GetJobCount() int32 {
	if m != nil {
		return m.JobCount
	}
	return 0
}

func (m *Job) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

type Jobs struct {
	// List of jobs.
	Jobs []*Job `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	// Total number of jobs in the system.
	Total                int32    `protobuf:"varint,20,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Jobs) Reset()         { *m = Jobs{} }
func (m *Jobs) String() string { return proto.CompactTextString(m) }
func (*Jobs) ProtoMessage()    {}
func (*Jobs) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{5}
}

func (m *Jobs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Jobs.Unmarshal(m, b)
}
func (m *Jobs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Jobs.Marshal(b, m, deterministic)
}
func (m *Jobs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Jobs.Merge(m, src)
}
func (m *Jobs) XXX_Size() int {
	return xxx_messageInfo_Jobs.Size(m)
}
func (m *Jobs) XXX_DiscardUnknown() {
	xxx_messageInfo_Jobs.DiscardUnknown(m)
}

var xxx_messageInfo_Jobs proto.InternalMessageInfo

func (m *Jobs) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *Jobs) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

type ResultsRow struct {
	// ID of the scanned node.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// ID of the report generated by the scan.
	ReportId string `protobuf:"bytes,2,opt,name=report_id,json=reportId,proto3" json:"report_id,omitempty"`
	// Status of the scan (completed, failed, aborted).
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// Result error message for failed scans.
	Result string `protobuf:"bytes,4,opt,name=result,proto3" json:"result,omitempty"`
	// ID of the scan.
	JobId string `protobuf:"bytes,5,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Start time of the scan.
	StartTime *timestamp.Timestamp `protobuf:"bytes,20,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End time of the scan.
	EndTime              *timestamp.Timestamp `protobuf:"bytes,21,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ResultsRow) Reset()         { *m = ResultsRow{} }
func (m *ResultsRow) String() string { return proto.CompactTextString(m) }
func (*ResultsRow) ProtoMessage()    {}
func (*ResultsRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_1bb72c425e853591, []int{6}
}

func (m *ResultsRow) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ResultsRow.Unmarshal(m, b)
}
func (m *ResultsRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ResultsRow.Marshal(b, m, deterministic)
}
func (m *ResultsRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResultsRow.Merge(m, src)
}
func (m *ResultsRow) XXX_Size() int {
	return xxx_messageInfo_ResultsRow.Size(m)
}
func (m *ResultsRow) XXX_DiscardUnknown() {
	xxx_messageInfo_ResultsRow.DiscardUnknown(m)
}

var xxx_messageInfo_ResultsRow proto.InternalMessageInfo

func (m *ResultsRow) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *ResultsRow) GetReportId() string {
	if m != nil {
		return m.ReportId
	}
	return ""
}

func (m *ResultsRow) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ResultsRow) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}

func (m *ResultsRow) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *ResultsRow) GetStartTime() *timestamp.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ResultsRow) GetEndTime() *timestamp.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func init() {
	proto.RegisterEnum("chef.automate.api.compliance.scanner.jobs.v1.Query_OrderType", Query_OrderType_name, Query_OrderType_value)
	proto.RegisterType((*RerunResponse)(nil), "chef.automate.api.compliance.scanner.jobs.v1.RerunResponse")
	proto.RegisterType((*Id)(nil), "chef.automate.api.compliance.scanner.jobs.v1.Id")
	proto.RegisterType((*Query)(nil), "chef.automate.api.compliance.scanner.jobs.v1.Query")
	proto.RegisterType((*ManagerFilter)(nil), "chef.automate.api.compliance.scanner.jobs.v1.ManagerFilter")
	proto.RegisterType((*Job)(nil), "chef.automate.api.compliance.scanner.jobs.v1.Job")
	proto.RegisterType((*Jobs)(nil), "chef.automate.api.compliance.scanner.jobs.v1.Jobs")
	proto.RegisterType((*ResultsRow)(nil), "chef.automate.api.compliance.scanner.jobs.v1.ResultsRow")
}

func init() {
	proto.RegisterFile("api/external/compliance/scanner/jobs/jobs.proto", fileDescriptor_1bb72c425e853591)
}

var fileDescriptor_1bb72c425e853591 = []byte{
	// 1141 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcd, 0x6e, 0x1c, 0x45,
	0x10, 0x66, 0xf6, 0x7f, 0xcb, 0xb1, 0x89, 0x5a, 0x8e, 0xd3, 0xac, 0x9d, 0x64, 0x19, 0x20, 0x5a,
	0x45, 0x78, 0x86, 0x38, 0x22, 0x0a, 0x1b, 0x2c, 0x12, 0x1c, 0x23, 0xad, 0x09, 0x02, 0xc6, 0xe1,
	0xc2, 0x65, 0xd5, 0x3b, 0x53, 0xbb, 0x1e, 0x33, 0x33, 0x3d, 0xf4, 0xf4, 0x18, 0x2c, 0xc4, 0x01,
	0x8e, 0xbe, 0xf2, 0x2c, 0x3e, 0x21, 0x0e, 0xbc, 0x00, 0x97, 0x88, 0x37, 0x40, 0xbc, 0x03, 0xe2,
	0x82, 0xba, 0x7b, 0x76, 0xed, 0x38, 0x59, 0xad, 0x77, 0xb9, 0x58, 0x5d, 0xd5, 0x55, 0x35, 0xdf,
	0x57, 0x5f, 0x95, 0xdd, 0x06, 0x97, 0xa5, 0xa1, 0x8b, 0xdf, 0x4b, 0x14, 0x09, 0x8b, 0x5c, 0x9f,
	0xc7, 0x69, 0x14, 0xb2, 0xc4, 0x47, 0x37, 0xf3, 0x59, 0x92, 0xa0, 0x70, 0x0f, 0xf9, 0x20, 0xd3,
	0x3f, 0x9c, 0x54, 0x70, 0xc9, 0xc9, 0xbb, 0xfe, 0x01, 0x0e, 0x1d, 0x96, 0x4b, 0x1e, 0x33, 0x89,
	0x0e, 0x4b, 0x43, 0xe7, 0x2c, 0xcb, 0x29, 0xb2, 0x1c, 0x9d, 0x70, 0x74, 0xb7, 0x75, 0x6b, 0xc4,
	0xf9, 0x28, 0x42, 0x57, 0xe7, 0x0e, 0xf2, 0xa1, 0x2b, 0xc3, 0x18, 0x33, 0xc9, 0xe2, 0xd4, 0x94,
	0x6b, 0x6d, 0x14, 0x01, 0x0a, 0x06, 0x4b, 0x12, 0x2e, 0x99, 0x0c, 0x79, 0x52, 0x7c, 0xac, 0xb5,
	0x7e, 0x31, 0x1d, 0xe3, 0x54, 0x1e, 0x17, 0x97, 0x8f, 0xd4, 0x77, 0x79, 0x82, 0x89, 0xcc, 0xdc,
	0x31, 0x9e, 0xcd, 0x91, 0x48, 0x7d, 0x13, 0xee, 0x6f, 0x8e, 0x30, 0xd9, 0x4c, 0x79, 0x14, 0xfa,
	0xc7, 0x6e, 0xc8, 0xe2, 0x57, 0x94, 0xbf, 0x73, 0x91, 0x7c, 0xcc, 0x13, 0xf7, 0xdb, 0x1c, 0xc5,
	0xb1, 0x9b, 0x32, 0xc1, 0x62, 0x94, 0x28, 0x8a, 0x58, 0xfb, 0x75, 0x58, 0xf6, 0x50, 0xe4, 0x89,
	0x87, 0x59, 0xca, 0x93, 0x0c, 0xed, 0x0e, 0x94, 0x7a, 0x01, 0x59, 0x81, 0x52, 0x18, 0x50, 0xab,
	0x6d, 0x75, 0x9a, 0x5e, 0x29, 0x0c, 0x08, 0x81, 0x4a, 0xc2, 0x62, 0xa4, 0x25, 0xed, 0xd1, 0x67,
	0xfb, 0xa7, 0x12, 0x54, 0xbf, 0x54, 0x55, 0xc9, 0x23, 0xa8, 0x0f, 0xc3, 0x48, 0x55, 0xa5, 0xab,
	0xed, 0x72, 0x67, 0x69, 0xeb, 0xb6, 0xf3, 0xca, 0x76, 0xc6, 0x3c, 0x71, 0x34, 0x0e, 0xe7, 0x13,
	0x1d, 0xee, 0x8d, 0xd3, 0xc8, 0x3e, 0x54, 0xb9, 0x08, 0x50, 0xd0, 0x6b, 0x6d, 0xab, 0xb3, 0xb2,
	0xb5, 0xed, 0xcc, 0x23, 0x87, 0xa3, 0x51, 0x38, 0x9f, 0xab, 0x02, 0xcf, 0x8e, 0x53, 0xf4, 0x4c,
	0x2d, 0x05, 0x3a, 0xe3, 0x42, 0xd2, 0x35, 0x03, 0x5a, 0x9d, 0x95, 0x2f, 0x65, 0x23, 0xa4, 0xd7,
	0xdb, 0x56, 0xa7, 0xea, 0xe9, 0x33, 0x79, 0x03, 0x1a, 0x29, 0x8a, 0xbe, 0xf6, 0x53, 0xed, 0xaf,
	0xa7, 0x28, 0xbe, 0x60, 0x23, 0xb4, 0x6f, 0x42, 0x73, 0x52, 0x96, 0xd4, 0xa1, 0xfc, 0x78, 0x7f,
	0xe7, 0xea, 0x6b, 0xa4, 0x01, 0x95, 0x27, 0xbb, 0xfb, 0x3b, 0x57, 0x2d, 0x3b, 0x85, 0xe5, 0xcf,
	0x58, 0xc2, 0x46, 0x28, 0x0c, 0x23, 0x72, 0x03, 0x20, 0x36, 0x8e, 0xfe, 0xa4, 0x81, 0xcd, 0xc2,
	0xd3, 0x0b, 0xce, 0x77, 0xaa, 0xb4, 0x50, 0xa7, 0xec, 0x5f, 0x6b, 0x50, 0xde, 0xe3, 0x83, 0xcb,
	0x28, 0xa4, 0x7c, 0xf2, 0x38, 0x45, 0x5a, 0x36, 0x3e, 0x75, 0x26, 0x14, 0xea, 0x6a, 0x58, 0x79,
	0x2e, 0x69, 0xc5, 0x70, 0x2d, 0x4c, 0x72, 0x1f, 0x2a, 0x92, 0x8d, 0xc6, 0x12, 0xda, 0xb3, 0x80,
	0x7d, 0x7a, 0xe4, 0xe9, 0x78, 0xf2, 0x01, 0x40, 0x26, 0x99, 0x90, 0x7d, 0x55, 0x48, 0x0b, 0xb8,
	0xb4, 0xd5, 0x72, 0xcc, 0x88, 0x3b, 0xe3, 0x11, 0x77, 0x9e, 0x8d, 0x37, 0xc4, 0x6b, 0xea, 0x68,
	0x65, 0x93, 0xf7, 0xa1, 0x81, 0x49, 0x60, 0x12, 0xd7, 0x66, 0x26, 0xd6, 0x31, 0x09, 0x74, 0xda,
	0x1a, 0xd4, 0x32, 0xc9, 0x64, 0x9e, 0x69, 0x19, 0x9b, 0x5e, 0x61, 0x29, 0x6e, 0x02, 0xa5, 0x08,
	0x31, 0xa3, 0x2d, 0xc3, 0xad, 0x30, 0xc9, 0x9b, 0x70, 0xa5, 0x38, 0xf6, 0x23, 0x1c, 0x4a, 0xba,
	0xae, 0xaf, 0x97, 0x0a, 0xdf, 0x53, 0x1c, 0x4a, 0xe2, 0xa9, 0xe4, 0x2c, 0x8f, 0x64, 0x46, 0x37,
	0x74, 0x07, 0x1e, 0xcc, 0x37, 0x84, 0x9e, 0x49, 0xf6, 0xf8, 0x77, 0xde, 0xb8, 0x10, 0x59, 0x85,
	0x6a, 0xc2, 0x03, 0xcc, 0x68, 0xd0, 0x2e, 0x77, 0x9a, 0x9e, 0x31, 0x48, 0x0b, 0x1a, 0xa9, 0xe0,
	0xc3, 0x30, 0xc2, 0x8c, 0xa2, 0xbe, 0x98, 0xd8, 0x6a, 0x7e, 0x54, 0x50, 0xdf, 0xe7, 0x79, 0x22,
	0xe9, 0x50, 0xc3, 0x6c, 0x2a, 0xcf, 0x8e, 0x72, 0x90, 0xb7, 0x60, 0xb9, 0x08, 0x2d, 0x22, 0x46,
	0x3a, 0xe2, 0x4a, 0xe1, 0x34, 0x41, 0x03, 0x58, 0xd1, 0x35, 0x32, 0x8c, 0xd0, 0x97, 0x5c, 0x64,
	0xf4, 0x40, 0x13, 0x7a, 0x38, 0x1f, 0xa1, 0x17, 0x06, 0xdb, 0x5b, 0x56, 0x25, 0xf7, 0xc7, 0x15,
	0xc9, 0x63, 0x58, 0xc9, 0xfc, 0x03, 0x0c, 0xf2, 0x08, 0x0b, 0xfd, 0xc2, 0x99, 0xfa, 0x2d, 0x4f,
	0x32, 0xb4, 0x8a, 0x37, 0x01, 0x04, 0xfa, 0xb9, 0x10, 0x98, 0xf8, 0x48, 0x0f, 0xb5, 0x92, 0xe7,
	0x3c, 0x64, 0x1d, 0x9a, 0x29, 0x13, 0x98, 0x48, 0xb5, 0x49, 0xdf, 0xe8, 0xeb, 0x86, 0x71, 0xf4,
	0x02, 0x75, 0x79, 0xc8, 0x07, 0x45, 0x13, 0x22, 0xdd, 0x84, 0xc6, 0x21, 0x1f, 0x98, 0x06, 0x50,
	0xa8, 0x07, 0x18, 0xa1, 0xc4, 0x80, 0xc6, 0x6d, 0xab, 0xd3, 0xf0, 0xc6, 0xa6, 0xed, 0x43, 0x65,
	0x8f, 0x0f, 0x32, 0xb2, 0x0b, 0x15, 0x45, 0x93, 0x5a, 0xba, 0x31, 0x77, 0xe7, 0x6b, 0xcc, 0x1e,
	0x1f, 0x78, 0x3a, 0x5d, 0xe9, 0x2b, 0xb9, 0x64, 0x11, 0x5d, 0xd5, 0x08, 0x8c, 0x61, 0xff, 0x6b,
	0x01, 0x9c, 0x4d, 0x03, 0xb9, 0x0e, 0x75, 0x2d, 0xc7, 0x64, 0x5d, 0x6b, 0xca, 0x34, 0x1c, 0x04,
	0xa6, 0x5c, 0x68, 0x82, 0x66, 0x6f, 0x1b, 0xc6, 0xd1, 0x0b, 0xce, 0xcd, 0x78, 0xf9, 0x85, 0x19,
	0x5f, 0x83, 0x9a, 0x99, 0x2e, 0xbd, 0xbe, 0x4d, 0xaf, 0xb0, 0xc8, 0x35, 0xa8, 0xa9, 0x86, 0x84,
	0x01, 0xad, 0x6a, 0x7f, 0xf5, 0x90, 0x0f, 0x7a, 0xc1, 0x85, 0xe5, 0x5c, 0x5d, 0x74, 0x39, 0xaf,
	0x5d, 0x7a, 0x39, 0xb7, 0xfe, 0x69, 0xc2, 0x92, 0xea, 0xf1, 0x3e, 0x8a, 0xa3, 0xd0, 0x47, 0xf2,
	0x87, 0x05, 0xb5, 0x1d, 0x81, 0x4c, 0x22, 0x99, 0xbf, 0xcf, 0xad, 0xf7, 0xe6, 0x4b, 0xe9, 0x05,
	0x76, 0xff, 0xe4, 0x94, 0x3e, 0x80, 0xeb, 0x67, 0x41, 0xdd, 0x22, 0xa8, 0xab, 0x25, 0xbb, 0xf1,
	0xf2, 0x85, 0x42, 0xdb, 0xf5, 0x35, 0xc4, 0x9f, 0x9f, 0xff, 0xf5, 0x4b, 0xe9, 0x86, 0x4d, 0xa7,
	0x3d, 0x19, 0xba, 0xd6, 0x1d, 0xf2, 0xdc, 0x82, 0x8a, 0x87, 0x2c, 0x20, 0x73, 0x63, 0x6b, 0xcd,
	0xdf, 0x00, 0x7b, 0x78, 0x72, 0x4a, 0xbb, 0xb0, 0x31, 0x85, 0x4e, 0xf7, 0x87, 0x30, 0xf8, 0x91,
	0xb4, 0xa6, 0x70, 0x1a, 0xa1, 0xd4, 0x84, 0x6c, 0xd2, 0x9e, 0xfa, 0x06, 0x0a, 0x03, 0x57, 0xd7,
	0xf8, 0xdd, 0x82, 0xda, 0x57, 0x69, 0xb0, 0xa0, 0x4c, 0x6b, 0x2f, 0x4d, 0xc6, 0xae, 0x7a, 0xd2,
	0xd8, 0xd1, 0xc9, 0x29, 0xdd, 0x9e, 0x81, 0x7e, 0x9a, 0x22, 0xb9, 0x46, 0xa3, 0x09, 0xbc, 0xd3,
	0x9a, 0x49, 0x40, 0x29, 0xf3, 0x9b, 0x05, 0xb5, 0x27, 0x7a, 0xd3, 0x17, 0xd0, 0x66, 0x1a, 0x85,
	0xf0, 0x7f, 0x50, 0x30, 0xbf, 0x76, 0x8c, 0x06, 0x77, 0x66, 0x6b, 0xf0, 0xa7, 0x05, 0x95, 0xa7,
	0x61, 0x26, 0xc9, 0xbd, 0x05, 0xde, 0x3f, 0xad, 0xad, 0xb9, 0x65, 0xcb, 0xec, 0xe0, 0xe4, 0x94,
	0xde, 0x9f, 0xbe, 0x2c, 0xeb, 0x53, 0x78, 0x45, 0x61, 0x66, 0x26, 0xeb, 0x6d, 0xfb, 0xd6, 0x54,
	0x56, 0x19, 0x32, 0xe1, 0x1f, 0x28, 0x5d, 0xfe, 0xb6, 0xa0, 0xaa, 0x5f, 0x99, 0x0b, 0xc8, 0xf2,
	0x70, 0xde, 0xbf, 0xc2, 0xe7, 0x1f, 0xb3, 0xc9, 0xc9, 0x29, 0xfd, 0x70, 0x86, 0x76, 0x1b, 0x53,
	0x38, 0x0a, 0x55, 0x49, 0x93, 0xec, 0x90, 0xdb, 0x53, 0x49, 0xea, 0xa8, 0xb1, 0x80, 0x1f, 0x7f,
	0xf4, 0xf5, 0xf6, 0x28, 0x94, 0x07, 0xf9, 0x40, 0x41, 0x74, 0x15, 0xf0, 0xc9, 0x13, 0xfe, 0x52,
	0xff, 0x91, 0x0c, 0x6a, 0x7a, 0xf8, 0xee, 0xfd, 0x17, 0x00, 0x00, 0xff, 0xff, 0x9d, 0x9c, 0x40,
	0xfe, 0xc0, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// JobsServiceClient is the client API for JobsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type JobsServiceClient interface {
	// Create a scan job
	//
	// Creates a scan job. A scan job executes Chef InSpec against the specified nodes.
	// Requires a user-specified name. Type should be `detect` (checks if the node is reachable and reports the
	// platform information for the nodes) or `exec` (executes a set of profiles against the nodes).
	// Nodes to scan may be specified by including an array of node IDs to scan or a node manager ID along with some optional
	// filtering information.
	// Exec jobs require at least one profile to be used as part of the Chef InSpec scan.
	// Optional recurrence schedules enable regularly scheduled (repeating) scans.
	//
	// Example:
	// ```
	// {
	// "name": "my testjob",
	// "tags": [],
	// "type": "exec",
	// "nodes": ["i07uc612-7e97-43f2-9b19-256abh785820"],
	// "profiles": ["https://github.com/dev-sec/linux-baseline/archive/master.tar.gz", "compliance://admin/ssh-baseline#2.2.0"],
	// "retries": 1,
	// "node_selectors":[
	// {
	// "manager_id":"e69dc612-7e67-43f2-9b19-256afd385820",
	// "filters":[{"key":"name","values":["ins*"],"exclude":false}]
	// }
	// ],
	// "recurrence":"DTSTART=20191231T045100Z;FREQ=DAILY;INTERVAL=1"
	// }
	// ```
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:create
	// ```
	Create(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Id, error)
	// Read a scan job
	//
	// Read the details of a scan job given an ID.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:get
	// ```
	Read(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Job, error)
	// Update a job
	//
	// PUT operation to update the details for a scan job, such as the name, profiles, node set, or recurrence schedule.
	// Please note that this is a PUT operation, so all scan job details included in the create function
	// should be included in the PUT message to update.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:update
	// ```
	Update(ctx context.Context, in *Job, opts ...grpc.CallOption) (*empty.Empty, error)
	// Delete a scan job
	//
	// Delete a scan job given an ID. Note this does not delete the report(s) generated by the scan job.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:delete
	// ```
	Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error)
	// List of scan jobs
	//
	// Returns a list of scan jobs matching the query.
	// Supports filtering, sorting, and pagination.
	// Valid filtering fields: job_type, parent_job, status
	// Valid sorting fields: name, type, status, start_time, end_time
	//
	// Example:
	// ```
	// {
	// "filters":[
	// {"key":"job_type","values":["exec"]},
	// {"key":"parent_job","values":[""]}
	// ],
	// "page":1,
	// "per_page":100,
	// "sort":"end_time",
	// "order":"DESC"
	// }
	// ```
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:list
	// ```
	List(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Jobs, error)
	// Rerun a scan job
	//
	// Does not create a new job in the database. Reads the job info given the job ID
	// and runs a scan. The latest job information is then updated to reflect this latest run.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:rerun
	// ```
	Rerun(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RerunResponse, error)
}

type jobsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewJobsServiceClient(cc grpc.ClientConnInterface) JobsServiceClient {
	return &jobsServiceClient{cc}
}

func (c *jobsServiceClient) Create(ctx context.Context, in *Job, opts ...grpc.CallOption) (*Id, error) {
	out := new(Id)
	err := c.cc.Invoke(ctx, "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsServiceClient) Read(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := c.cc.Invoke(ctx, "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Read", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsServiceClient) Update(ctx context.Context, in *Job, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsServiceClient) Delete(ctx context.Context, in *Id, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsServiceClient) List(ctx context.Context, in *Query, opts ...grpc.CallOption) (*Jobs, error) {
	out := new(Jobs)
	err := c.cc.Invoke(ctx, "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/List", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *jobsServiceClient) Rerun(ctx context.Context, in *Id, opts ...grpc.CallOption) (*RerunResponse, error) {
	out := new(RerunResponse)
	err := c.cc.Invoke(ctx, "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Rerun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// JobsServiceServer is the server API for JobsService service.
type JobsServiceServer interface {
	// Create a scan job
	//
	// Creates a scan job. A scan job executes Chef InSpec against the specified nodes.
	// Requires a user-specified name. Type should be `detect` (checks if the node is reachable and reports the
	// platform information for the nodes) or `exec` (executes a set of profiles against the nodes).
	// Nodes to scan may be specified by including an array of node IDs to scan or a node manager ID along with some optional
	// filtering information.
	// Exec jobs require at least one profile to be used as part of the Chef InSpec scan.
	// Optional recurrence schedules enable regularly scheduled (repeating) scans.
	//
	// Example:
	// ```
	// {
	// "name": "my testjob",
	// "tags": [],
	// "type": "exec",
	// "nodes": ["i07uc612-7e97-43f2-9b19-256abh785820"],
	// "profiles": ["https://github.com/dev-sec/linux-baseline/archive/master.tar.gz", "compliance://admin/ssh-baseline#2.2.0"],
	// "retries": 1,
	// "node_selectors":[
	// {
	// "manager_id":"e69dc612-7e67-43f2-9b19-256afd385820",
	// "filters":[{"key":"name","values":["ins*"],"exclude":false}]
	// }
	// ],
	// "recurrence":"DTSTART=20191231T045100Z;FREQ=DAILY;INTERVAL=1"
	// }
	// ```
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:create
	// ```
	Create(context.Context, *Job) (*Id, error)
	// Read a scan job
	//
	// Read the details of a scan job given an ID.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:get
	// ```
	Read(context.Context, *Id) (*Job, error)
	// Update a job
	//
	// PUT operation to update the details for a scan job, such as the name, profiles, node set, or recurrence schedule.
	// Please note that this is a PUT operation, so all scan job details included in the create function
	// should be included in the PUT message to update.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:update
	// ```
	Update(context.Context, *Job) (*empty.Empty, error)
	// Delete a scan job
	//
	// Delete a scan job given an ID. Note this does not delete the report(s) generated by the scan job.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:delete
	// ```
	Delete(context.Context, *Id) (*empty.Empty, error)
	// List of scan jobs
	//
	// Returns a list of scan jobs matching the query.
	// Supports filtering, sorting, and pagination.
	// Valid filtering fields: job_type, parent_job, status
	// Valid sorting fields: name, type, status, start_time, end_time
	//
	// Example:
	// ```
	// {
	// "filters":[
	// {"key":"job_type","values":["exec"]},
	// {"key":"parent_job","values":[""]}
	// ],
	// "page":1,
	// "per_page":100,
	// "sort":"end_time",
	// "order":"DESC"
	// }
	// ```
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:list
	// ```
	List(context.Context, *Query) (*Jobs, error)
	// Rerun a scan job
	//
	// Does not create a new job in the database. Reads the job info given the job ID
	// and runs a scan. The latest job information is then updated to reflect this latest run.
	//
	// Authorization Action:
	//
	// ```
	// compliance:scannerJobs:rerun
	// ```
	Rerun(context.Context, *Id) (*RerunResponse, error)
}

// UnimplementedJobsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedJobsServiceServer struct {
}

func (*UnimplementedJobsServiceServer) Create(ctx context.Context, req *Job) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedJobsServiceServer) Read(ctx context.Context, req *Id) (*Job, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (*UnimplementedJobsServiceServer) Update(ctx context.Context, req *Job) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (*UnimplementedJobsServiceServer) Delete(ctx context.Context, req *Id) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (*UnimplementedJobsServiceServer) List(ctx context.Context, req *Query) (*Jobs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (*UnimplementedJobsServiceServer) Rerun(ctx context.Context, req *Id) (*RerunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rerun not implemented")
}

func RegisterJobsServiceServer(s *grpc.Server, srv JobsServiceServer) {
	s.RegisterService(&_JobsService_serviceDesc, srv)
}

func _JobsService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServiceServer).Create(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobsService_Read_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServiceServer).Read(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Read",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServiceServer).Read(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobsService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Job)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServiceServer).Update(ctx, req.(*Job))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobsService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServiceServer).Delete(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobsService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Query)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServiceServer).List(ctx, req.(*Query))
	}
	return interceptor(ctx, in, info, handler)
}

func _JobsService_Rerun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(JobsServiceServer).Rerun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.api.compliance.scanner.jobs.v1.JobsService/Rerun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(JobsServiceServer).Rerun(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

var _JobsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chef.automate.api.compliance.scanner.jobs.v1.JobsService",
	HandlerType: (*JobsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _JobsService_Create_Handler,
		},
		{
			MethodName: "Read",
			Handler:    _JobsService_Read_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _JobsService_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _JobsService_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _JobsService_List_Handler,
		},
		{
			MethodName: "Rerun",
			Handler:    _JobsService_Rerun_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/external/compliance/scanner/jobs/jobs.proto",
}
