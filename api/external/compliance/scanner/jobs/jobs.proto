syntax = "proto3";

package chef.automate.api.compliance.scanner.jobs.v1;
option go_package = "github.com/chef/automate/api/external/compliance/scanner/jobs";

import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";
import "google/protobuf/empty.proto";

import "external/annotations/iam/annotations.proto";

import "external/common/query/parameters.proto";

service JobsService {
	/*
	Create a scan job

	Creates a scan job. A scan job executes Chef InSpec against the specified nodes.
	Requires a user-specified name. Type should be `detect` (checks if the node is reachable and reports the
	platform information for the nodes) or `exec` (executes a set of profiles against the nodes).
	Nodes to scan may be specified by including an array of node IDs to scan or a node manager ID along with some optional
	filtering information.
	Exec jobs require at least one profile to be used as part of the Chef InSpec scan.
	Optional recurrence schedules enable regularly scheduled (repeating) scans.

	Example:
	```
	{  
		"name": "my testjob",
		"tags": [],
		"type": "exec",
		"nodes": ["i07uc612-7e97-43f2-9b19-256abh785820"],
		"profiles": ["https://github.com/dev-sec/linux-baseline/archive/master.tar.gz", "compliance://admin/ssh-baseline#2.2.0"],
		"retries": 1,
		"node_selectors":[
			{
				"manager_id":"e69dc612-7e67-43f2-9b19-256afd385820",
				"filters":[{"key":"name","values":["ins*"],"exclude":false}]
			}
		],
		"recurrence":"DTSTART=20191231T045100Z;FREQ=DAILY;INTERVAL=1"
	}
	```

	Authorization Action:

	```
	compliance:scannerJobs:create
	```
	*/
	rpc Create(Job) returns (Id) {
		option (google.api.http) = {
			post: "/api/v0/compliance/scanner/jobs"
			body: "*"
		};
		option (chef.automate.api.iam.policy) = {
			resource: "compliance:scanner:jobs"
			action: "compliance:scannerJobs:create"
		};
	};

	/*
	Read a scan job

	Read the details of a scan job given an ID.

	Authorization Action:

	```
	compliance:scannerJobs:get
	```
	*/
	rpc Read(Id) returns (Job) {
		option (google.api.http) = {
			get: "/api/v0/compliance/scanner/jobs/id/{id}"
		};
		option (chef.automate.api.iam.policy) = {
			resource: "compliance:scanner:jobs:{id}"
			action: "compliance:scannerJobs:get"
		};
	};

	/*
	Update a job

	PUT operation to update the details for a scan job, such as the name, profiles, node set, or recurrence schedule.
	Please note that this is a PUT operation, so all scan job details included in the create function
	should be included in the PUT message to update.	

	Authorization Action:

	```
	compliance:scannerJobs:update
	```
	*/
	rpc Update(Job) returns (google.protobuf.Empty) {
		option (google.api.http) = {
			put: "/api/v0/compliance/scanner/jobs/id/{id}"
			body: "*"
		};
		option (chef.automate.api.iam.policy) = {
			resource: "compliance:scanner:jobs:{id}"
			action: "compliance:scannerJobs:update"
		};
	};

	/*
	Delete a scan job

	Delete a scan job given an ID. Note this does not delete the report(s) generated by the scan job.

	Authorization Action:

	```
	compliance:scannerJobs:delete
	```
	*/
	rpc Delete(Id) returns (google.protobuf.Empty) {
		option (google.api.http) = {
			delete: "/api/v0/compliance/scanner/jobs/id/{id}"
		};
		option (chef.automate.api.iam.policy) = {
			resource: "compliance:scanner:jobs:{id}"
			action: "compliance:scannerJobs:delete"
		};
	};

	/*
	List of scan jobs

	Returns a list of scan jobs matching the query.
	Supports filtering, sorting, and pagination.
	Valid filtering fields: job_type, parent_job, status
	Valid sorting fields: name, type, status, start_time, end_time

	Example:
	```
 	{
		"filters":[
			{"key":"job_type","values":["exec"]},
			{"key":"parent_job","values":[""]}
		],
		"page":1,
		"per_page":100,
		"sort":"end_time",
		"order":"DESC"
	} 
	```

	Authorization Action:

	```
	compliance:scannerJobs:list
	```
	*/
	rpc List(Query) returns (Jobs) {
		option (google.api.http) = {
			post: "/api/v0/compliance/scanner/jobs/search"
			body: "*"
		};
		option (chef.automate.api.iam.policy) = {
			resource: "compliance:scanner:jobs"
			action: "compliance:scannerJobs:list"
		};
	};

	/*
	Rerun a scan job

	Does not create a new job in the database. Reads the job info given the job ID
	and runs a scan. The latest job information is then updated to reflect this latest run.	

	Authorization Action:

	```
	compliance:scannerJobs:rerun
	```
	*/
	rpc Rerun(Id) returns (RerunResponse) {
		option (google.api.http) = {
			get: "/api/v0/compliance/scanner/jobs/rerun/id/{id}"
		};
		option (chef.automate.api.iam.policy) = {
			resource: "compliance:scanner:jobs:{id}"
			action: "compliance:scannerJobs:rerun"
		};
	};
}

message RerunResponse {}

message Id {
	// Unique ID (UUID) assigned to object.
	string id = 1;
	// Name of object.
	string name = 2;
}

message Query {
	// Use filters to limit the set of items returned.
	repeated chef.automate.api.common.query.Filter filters = 20;
	// Return the results in ascending or descending order.
	enum OrderType {
		ASC = 0;
		DESC = 1;
	}
	OrderType order = 21;
	// Sort the results on a specific field.
	string sort = 22;
	// Starting page for the results.
	int32 page = 23;
	// The number of results on each page.
	int32 per_page = 24;
}

message ManagerFilter {
	// Unique ID of a node manager.
	string manager_id = 1;
	// Use filters to limit the set of items returned.
	repeated chef.automate.api.common.query.Filter filters = 2;
}

message Job {
	// Unique ID (UUID) of the scan job.
	string id = 1;
	// User-specified name of the scan job.
	string name = 2;
	// Determines the type of Chef InSpec run, `detect` or `exec`.
	string type = 3;
	// Desired timeout (in seconds) for the scan job execution. Default: 7200 for exec jobs, 600 for detect jobs.
	int32 timeout = 4;
	// Tags to assign to the scan job.
	repeated chef.automate.api.common.query.Kv tags = 20;
	// Start time of the scan job, assigned by the service.
	google.protobuf.Timestamp start_time = 21;
	// End time of the scan job, assigned by the service.
	google.protobuf.Timestamp end_time = 22;
	// Status of the scan job, assigned by the service.
	string status = 23;
	// Number of times to retry the scan job. Default: 3.
	int32 retries = 26;
	// Number of retries left, assigned by the service.
	int32 retries_left = 27;
	// Results of the scan job, including a report ID if one was generated.
	repeated ResultsRow results = 28;
	// List of node IDs to associate with the scan job.
	repeated string nodes = 100;
	// List of profiles to execute as part of the scan job.
	repeated string profiles = 101;
	// Count of nodes to be scanned as part of the job, assigned by the service.
	int32 node_count = 102;
	// Count of profiles to be executed as part of the job.
	int32 profile_count = 103;
	// Set of node manager IDs and filters to associate with the scan job.
	repeated ManagerFilter node_selectors = 104;
	// Next scheduled scan execution time.
	google.protobuf.Timestamp scheduled_time = 105;
	// Recurrence schedule string for the job.
	string recurrence = 106;
	// ID of parent job to associate with the job, if any.
	string parent_id = 107;
	// Count of scans executed by the job.
	int32 job_count = 108;
	// Boolean used to denote the job has been marked as "deleted" by the user.
	bool deleted = 109;
}

message Jobs {
	// List of jobs.
	repeated Job jobs = 1;
	// Total number of jobs in the system.
	int32 total = 20;
}

message ResultsRow {
	// ID of the scanned node.
	string node_id = 1;
	// ID of the report generated by the scan.
	string report_id = 2;
	// Status of the scan (completed, failed, aborted). 
	string status = 3;
	// Result error message for failed scans.
	string result = 4;
	// ID of the scan.
	string job_id = 5;
	// Start time of the scan. 
	google.protobuf.Timestamp start_time = 20;
	// End time of the scan. 
	google.protobuf.Timestamp end_time = 21;
}
