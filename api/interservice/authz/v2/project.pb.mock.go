// Code generated by protoc-gen-grpc-mock. DO NOT EDIT.
// source: api/interservice/authz/v2/project.proto

package v2

import (
	"context"

	event "github.com/chef/automate/api/interservice/event"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// verify that the mock satisfies the ProjectsServer interface (at compile time)
var _ ProjectsServer = &ProjectsServerMock{}

// NewProjectsServerMock gives you a fresh instance of ProjectsServerMock.
func NewProjectsServerMock() *ProjectsServerMock {
	return &ProjectsServerMock{validateRequests: true}
}

// NewProjectsServerMockWithoutValidation gives you a fresh instance of
// ProjectsServerMock which does not attempt to validate requests before passing
// them to their respective '*Func'.
func NewProjectsServerMockWithoutValidation() *ProjectsServerMock {
	return &ProjectsServerMock{}
}

// ProjectsServerMock is the mock-what-you-want struct that stubs all not-overridden
// methods with "not implemented" returns
type ProjectsServerMock struct {
	validateRequests                 bool
	UpdateProjectFunc                func(context.Context, *UpdateProjectReq) (*UpdateProjectResp, error)
	CreateProjectFunc                func(context.Context, *CreateProjectReq) (*CreateProjectResp, error)
	GetProjectFunc                   func(context.Context, *GetProjectReq) (*GetProjectResp, error)
	DeleteProjectFunc                func(context.Context, *DeleteProjectReq) (*DeleteProjectResp, error)
	ListProjectsFunc                 func(context.Context, *ListProjectsReq) (*ListProjectsResp, error)
	ListProjectsForIntrospectionFunc func(context.Context, *ListProjectsReq) (*ListProjectsResp, error)
	HandleEventFunc                  func(context.Context, *event.EventMsg) (*event.EventResponse, error)
	ApplyRulesStartFunc              func(context.Context, *ApplyRulesStartReq) (*ApplyRulesStartResp, error)
	ApplyRulesCancelFunc             func(context.Context, *ApplyRulesCancelReq) (*ApplyRulesCancelResp, error)
	ApplyRulesStatusFunc             func(context.Context, *ApplyRulesStatusReq) (*ApplyRulesStatusResp, error)
	CreateRuleFunc                   func(context.Context, *CreateRuleReq) (*CreateRuleResp, error)
	UpdateRuleFunc                   func(context.Context, *UpdateRuleReq) (*UpdateRuleResp, error)
	GetRuleFunc                      func(context.Context, *GetRuleReq) (*GetRuleResp, error)
	ListRulesFunc                    func(context.Context, *ListRulesReq) (*ListRulesResp, error)
	ListRulesForProjectFunc          func(context.Context, *ListRulesForProjectReq) (*ListRulesForProjectResp, error)
	DeleteRuleFunc                   func(context.Context, *DeleteRuleReq) (*DeleteRuleResp, error)
	ListRulesForAllProjectsFunc      func(context.Context, *ListRulesForAllProjectsReq) (*ListRulesForAllProjectsResp, error)
}

func (m *ProjectsServerMock) UpdateProject(ctx context.Context, req *UpdateProjectReq) (*UpdateProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.UpdateProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'UpdateProject' not implemented")
}

func (m *ProjectsServerMock) CreateProject(ctx context.Context, req *CreateProjectReq) (*CreateProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.CreateProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'CreateProject' not implemented")
}

func (m *ProjectsServerMock) GetProject(ctx context.Context, req *GetProjectReq) (*GetProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.GetProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'GetProject' not implemented")
}

func (m *ProjectsServerMock) DeleteProject(ctx context.Context, req *DeleteProjectReq) (*DeleteProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.DeleteProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'DeleteProject' not implemented")
}

func (m *ProjectsServerMock) ListProjects(ctx context.Context, req *ListProjectsReq) (*ListProjectsResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListProjectsFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListProjects' not implemented")
}

func (m *ProjectsServerMock) ListProjectsForIntrospection(ctx context.Context, req *ListProjectsReq) (*ListProjectsResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListProjectsForIntrospectionFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListProjectsForIntrospection' not implemented")
}

func (m *ProjectsServerMock) HandleEvent(ctx context.Context, req *event.EventMsg) (*event.EventResponse, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.HandleEventFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'HandleEvent' not implemented")
}

func (m *ProjectsServerMock) ApplyRulesStart(ctx context.Context, req *ApplyRulesStartReq) (*ApplyRulesStartResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ApplyRulesStartFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ApplyRulesStart' not implemented")
}

func (m *ProjectsServerMock) ApplyRulesCancel(ctx context.Context, req *ApplyRulesCancelReq) (*ApplyRulesCancelResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ApplyRulesCancelFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ApplyRulesCancel' not implemented")
}

func (m *ProjectsServerMock) ApplyRulesStatus(ctx context.Context, req *ApplyRulesStatusReq) (*ApplyRulesStatusResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ApplyRulesStatusFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ApplyRulesStatus' not implemented")
}

func (m *ProjectsServerMock) CreateRule(ctx context.Context, req *CreateRuleReq) (*CreateRuleResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.CreateRuleFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'CreateRule' not implemented")
}

func (m *ProjectsServerMock) UpdateRule(ctx context.Context, req *UpdateRuleReq) (*UpdateRuleResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.UpdateRuleFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'UpdateRule' not implemented")
}

func (m *ProjectsServerMock) GetRule(ctx context.Context, req *GetRuleReq) (*GetRuleResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.GetRuleFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'GetRule' not implemented")
}

func (m *ProjectsServerMock) ListRules(ctx context.Context, req *ListRulesReq) (*ListRulesResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListRulesFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListRules' not implemented")
}

func (m *ProjectsServerMock) ListRulesForProject(ctx context.Context, req *ListRulesForProjectReq) (*ListRulesForProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListRulesForProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListRulesForProject' not implemented")
}

func (m *ProjectsServerMock) DeleteRule(ctx context.Context, req *DeleteRuleReq) (*DeleteRuleResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.DeleteRuleFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'DeleteRule' not implemented")
}

func (m *ProjectsServerMock) ListRulesForAllProjects(ctx context.Context, req *ListRulesForAllProjectsReq) (*ListRulesForAllProjectsResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListRulesForAllProjectsFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListRulesForAllProjects' not implemented")
}

// Reset resets all overridden functions
func (m *ProjectsServerMock) Reset() {
	m.UpdateProjectFunc = nil
	m.CreateProjectFunc = nil
	m.GetProjectFunc = nil
	m.DeleteProjectFunc = nil
	m.ListProjectsFunc = nil
	m.ListProjectsForIntrospectionFunc = nil
	m.HandleEventFunc = nil
	m.ApplyRulesStartFunc = nil
	m.ApplyRulesCancelFunc = nil
	m.ApplyRulesStatusFunc = nil
	m.CreateRuleFunc = nil
	m.UpdateRuleFunc = nil
	m.GetRuleFunc = nil
	m.ListRulesFunc = nil
	m.ListRulesForProjectFunc = nil
	m.DeleteRuleFunc = nil
	m.ListRulesForAllProjectsFunc = nil
}
