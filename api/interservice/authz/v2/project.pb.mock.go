// Code generated by protoc-gen-grpc-mock. DO NOT EDIT.
// source: api/interservice/authz/v2/project.proto

package v2

import (
	"context"

	event "github.com/chef/automate/api/interservice/event"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// verify that the mock satisfies the ProjectsServer interface (at compile time)
var _ ProjectsServer = &ProjectsServerMock{}

// NewProjectsServerMock gives you a fresh instance of ProjectsServerMock.
func NewProjectsServerMock() *ProjectsServerMock {
	return &ProjectsServerMock{validateRequests: true}
}

// NewProjectsServerMockWithoutValidation gives you a fresh instance of
// ProjectsServerMock which does not attempt to validate requests before passing
// them to their respective '*Func'.
func NewProjectsServerMockWithoutValidation() *ProjectsServerMock {
	return &ProjectsServerMock{}
}

// ProjectsServerMock is the mock-what-you-want struct that stubs all not-overridden
// methods with "not implemented" returns
type ProjectsServerMock struct {
	validateRequests        bool
	UpdateProjectFunc       func(context.Context, *UpdateProjectReq) (*UpdateProjectResp, error)
	CreateProjectFunc       func(context.Context, *CreateProjectReq) (*CreateProjectResp, error)
	GetProjectFunc          func(context.Context, *GetProjectReq) (*GetProjectResp, error)
	DeleteProjectFunc       func(context.Context, *DeleteProjectReq) (*DeleteProjectResp, error)
	ListProjectsFunc        func(context.Context, *ListProjectsReq) (*ListProjectsResp, error)
	ListProjectRulesFunc    func(context.Context, *ListProjectRulesReq) (*ProjectCollectionRulesResp, error)
	GetProjectRulesFunc     func(context.Context, *GetProjectRulesReq) (*GetProjectRulesResp, error)
	HandleEventFunc         func(context.Context, *event.EventMsg) (*event.EventResponse, error)
	ProjectUpdateStatusFunc func(context.Context, *ProjectUpdateStatusReq) (*ProjectUpdateStatusResp, error)
	ProjectUpdateCancelFunc func(context.Context, *ProjectUpdateStatusReq) (*ProjectUpdateCancelResp, error)
	CreateRuleFunc          func(context.Context, *CreateRuleReq) (*CreateRuleResp, error)
}

func (m *ProjectsServerMock) UpdateProject(ctx context.Context, req *UpdateProjectReq) (*UpdateProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.UpdateProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'UpdateProject' not implemented")
}

func (m *ProjectsServerMock) CreateProject(ctx context.Context, req *CreateProjectReq) (*CreateProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.CreateProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'CreateProject' not implemented")
}

func (m *ProjectsServerMock) GetProject(ctx context.Context, req *GetProjectReq) (*GetProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.GetProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'GetProject' not implemented")
}

func (m *ProjectsServerMock) DeleteProject(ctx context.Context, req *DeleteProjectReq) (*DeleteProjectResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.DeleteProjectFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'DeleteProject' not implemented")
}

func (m *ProjectsServerMock) ListProjects(ctx context.Context, req *ListProjectsReq) (*ListProjectsResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListProjectsFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListProjects' not implemented")
}

func (m *ProjectsServerMock) ListProjectRules(ctx context.Context, req *ListProjectRulesReq) (*ProjectCollectionRulesResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ListProjectRulesFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ListProjectRules' not implemented")
}

func (m *ProjectsServerMock) GetProjectRules(ctx context.Context, req *GetProjectRulesReq) (*GetProjectRulesResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.GetProjectRulesFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'GetProjectRules' not implemented")
}

func (m *ProjectsServerMock) HandleEvent(ctx context.Context, req *event.EventMsg) (*event.EventResponse, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.HandleEventFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'HandleEvent' not implemented")
}

func (m *ProjectsServerMock) ProjectUpdateStatus(ctx context.Context, req *ProjectUpdateStatusReq) (*ProjectUpdateStatusResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ProjectUpdateStatusFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ProjectUpdateStatus' not implemented")
}

func (m *ProjectsServerMock) ProjectUpdateCancel(ctx context.Context, req *ProjectUpdateStatusReq) (*ProjectUpdateCancelResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.ProjectUpdateCancelFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'ProjectUpdateCancel' not implemented")
}

func (m *ProjectsServerMock) CreateRule(ctx context.Context, req *CreateRuleReq) (*CreateRuleResp, error) {
	if msg, ok := interface{}(req).(interface{ Validate() error }); m.validateRequests && ok {
		if err := msg.Validate(); err != nil {
			return nil, status.Error(codes.InvalidArgument, err.Error())
		}
	}
	if f := m.CreateRuleFunc; f != nil {
		return f(ctx, req)
	}
	return nil, status.Error(codes.Internal, "mock: 'CreateRule' not implemented")
}

// Reset resets all overridden functions
func (m *ProjectsServerMock) Reset() {
	m.UpdateProjectFunc = nil
	m.CreateProjectFunc = nil
	m.GetProjectFunc = nil
	m.DeleteProjectFunc = nil
	m.ListProjectsFunc = nil
	m.ListProjectRulesFunc = nil
	m.GetProjectRulesFunc = nil
	m.HandleEventFunc = nil
	m.ProjectUpdateStatusFunc = nil
	m.ProjectUpdateCancelFunc = nil
	m.CreateRuleFunc = nil
}
