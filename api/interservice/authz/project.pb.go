// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.19.0
// source: interservice/authz/project.proto

package authz

import (
	context "context"
	_ "github.com/envoyproxy/protoc-gen-validate/validate"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ProjectRuleTypes int32

const (
	ProjectRuleTypes_NODE  ProjectRuleTypes = 0
	ProjectRuleTypes_EVENT ProjectRuleTypes = 1
)

// Enum value maps for ProjectRuleTypes.
var (
	ProjectRuleTypes_name = map[int32]string{
		0: "NODE",
		1: "EVENT",
	}
	ProjectRuleTypes_value = map[string]int32{
		"NODE":  0,
		"EVENT": 1,
	}
)

func (x ProjectRuleTypes) Enum() *ProjectRuleTypes {
	p := new(ProjectRuleTypes)
	*p = x
	return p
}

func (x ProjectRuleTypes) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectRuleTypes) Descriptor() protoreflect.EnumDescriptor {
	return file_interservice_authz_project_proto_enumTypes[0].Descriptor()
}

func (ProjectRuleTypes) Type() protoreflect.EnumType {
	return &file_interservice_authz_project_proto_enumTypes[0]
}

func (x ProjectRuleTypes) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectRuleTypes.Descriptor instead.
func (ProjectRuleTypes) EnumDescriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{0}
}

type ProjectRuleConditionAttributes int32

const (
	ProjectRuleConditionAttributes_CHEF_SERVER       ProjectRuleConditionAttributes = 0
	ProjectRuleConditionAttributes_CHEF_ORGANIZATION ProjectRuleConditionAttributes = 1
	ProjectRuleConditionAttributes_ENVIRONMENT       ProjectRuleConditionAttributes = 2
	ProjectRuleConditionAttributes_CHEF_ROLE         ProjectRuleConditionAttributes = 3
	ProjectRuleConditionAttributes_CHEF_TAG          ProjectRuleConditionAttributes = 4
	ProjectRuleConditionAttributes_CHEF_POLICY_GROUP ProjectRuleConditionAttributes = 5
	ProjectRuleConditionAttributes_CHEF_POLICY_NAME  ProjectRuleConditionAttributes = 6
)

// Enum value maps for ProjectRuleConditionAttributes.
var (
	ProjectRuleConditionAttributes_name = map[int32]string{
		0: "CHEF_SERVER",
		1: "CHEF_ORGANIZATION",
		2: "ENVIRONMENT",
		3: "CHEF_ROLE",
		4: "CHEF_TAG",
		5: "CHEF_POLICY_GROUP",
		6: "CHEF_POLICY_NAME",
	}
	ProjectRuleConditionAttributes_value = map[string]int32{
		"CHEF_SERVER":       0,
		"CHEF_ORGANIZATION": 1,
		"ENVIRONMENT":       2,
		"CHEF_ROLE":         3,
		"CHEF_TAG":          4,
		"CHEF_POLICY_GROUP": 5,
		"CHEF_POLICY_NAME":  6,
	}
)

func (x ProjectRuleConditionAttributes) Enum() *ProjectRuleConditionAttributes {
	p := new(ProjectRuleConditionAttributes)
	*p = x
	return p
}

func (x ProjectRuleConditionAttributes) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectRuleConditionAttributes) Descriptor() protoreflect.EnumDescriptor {
	return file_interservice_authz_project_proto_enumTypes[1].Descriptor()
}

func (ProjectRuleConditionAttributes) Type() protoreflect.EnumType {
	return &file_interservice_authz_project_proto_enumTypes[1]
}

func (x ProjectRuleConditionAttributes) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectRuleConditionAttributes.Descriptor instead.
func (ProjectRuleConditionAttributes) EnumDescriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{1}
}

type ProjectRuleConditionOperators int32

const (
	ProjectRuleConditionOperators_MEMBER_OF ProjectRuleConditionOperators = 0
	ProjectRuleConditionOperators_EQUALS    ProjectRuleConditionOperators = 1
)

// Enum value maps for ProjectRuleConditionOperators.
var (
	ProjectRuleConditionOperators_name = map[int32]string{
		0: "MEMBER_OF",
		1: "EQUALS",
	}
	ProjectRuleConditionOperators_value = map[string]int32{
		"MEMBER_OF": 0,
		"EQUALS":    1,
	}
)

func (x ProjectRuleConditionOperators) Enum() *ProjectRuleConditionOperators {
	p := new(ProjectRuleConditionOperators)
	*p = x
	return p
}

func (x ProjectRuleConditionOperators) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProjectRuleConditionOperators) Descriptor() protoreflect.EnumDescriptor {
	return file_interservice_authz_project_proto_enumTypes[2].Descriptor()
}

func (ProjectRuleConditionOperators) Type() protoreflect.EnumType {
	return &file_interservice_authz_project_proto_enumTypes[2]
}

func (x ProjectRuleConditionOperators) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProjectRuleConditionOperators.Descriptor instead.
func (ProjectRuleConditionOperators) EnumDescriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{2}
}

type Project struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" toml:"name,omitempty" mapstructure:"name,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	Type          Type                   `protobuf:"varint,3,opt,name=type,proto3,enum=chef.automate.domain.authz.Type" json:"type,omitempty" toml:"type,omitempty" mapstructure:"type,omitempty"`
	Status        string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty" toml:"status,omitempty" mapstructure:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Project) Reset() {
	*x = Project{}
	mi := &file_interservice_authz_project_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Project) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Project) ProtoMessage() {}

func (x *Project) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Project.ProtoReflect.Descriptor instead.
func (*Project) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{0}
}

func (x *Project) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Project) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Project) GetType() Type {
	if x != nil {
		return x.Type
	}
	return Type_CHEF_MANAGED
}

func (x *Project) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

// Projects, unlike all other resources allowing 64 characters,
// are restricted to 48 because the id serves as a base for generated policies and teams.
type CreateProjectReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" toml:"name,omitempty" mapstructure:"name,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	SkipPolicies  bool                   `protobuf:"varint,3,opt,name=skip_policies,json=skipPolicies,proto3" json:"skip_policies,omitempty" toml:"skip_policies,omitempty" mapstructure:"skip_policies,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateProjectReq) Reset() {
	*x = CreateProjectReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateProjectReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateProjectReq) ProtoMessage() {}

func (x *CreateProjectReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateProjectReq.ProtoReflect.Descriptor instead.
func (*CreateProjectReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{1}
}

func (x *CreateProjectReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateProjectReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CreateProjectReq) GetSkipPolicies() bool {
	if x != nil {
		return x.SkipPolicies
	}
	return false
}

type CreateProjectResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Project       *Project               `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty" toml:"project,omitempty" mapstructure:"project,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateProjectResp) Reset() {
	*x = CreateProjectResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateProjectResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateProjectResp) ProtoMessage() {}

func (x *CreateProjectResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateProjectResp.ProtoReflect.Descriptor instead.
func (*CreateProjectResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{2}
}

func (x *CreateProjectResp) GetProject() *Project {
	if x != nil {
		return x.Project
	}
	return nil
}

type GetProjectReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetProjectReq) Reset() {
	*x = GetProjectReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetProjectReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetProjectReq) ProtoMessage() {}

func (x *GetProjectReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetProjectReq.ProtoReflect.Descriptor instead.
func (*GetProjectReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{3}
}

func (x *GetProjectReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type GetProjectResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Project       *Project               `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty" toml:"project,omitempty" mapstructure:"project,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetProjectResp) Reset() {
	*x = GetProjectResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetProjectResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetProjectResp) ProtoMessage() {}

func (x *GetProjectResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetProjectResp.ProtoReflect.Descriptor instead.
func (*GetProjectResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{4}
}

func (x *GetProjectResp) GetProject() *Project {
	if x != nil {
		return x.Project
	}
	return nil
}

type ListProjectsReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProjectsReq) Reset() {
	*x = ListProjectsReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProjectsReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProjectsReq) ProtoMessage() {}

func (x *ListProjectsReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProjectsReq.ProtoReflect.Descriptor instead.
func (*ListProjectsReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{5}
}

type ListProjectsResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Projects      []*Project             `protobuf:"bytes,1,rep,name=projects,proto3" json:"projects,omitempty" toml:"projects,omitempty" mapstructure:"projects,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProjectsResp) Reset() {
	*x = ListProjectsResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProjectsResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProjectsResp) ProtoMessage() {}

func (x *ListProjectsResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProjectsResp.ProtoReflect.Descriptor instead.
func (*ListProjectsResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{6}
}

func (x *ListProjectsResp) GetProjects() []*Project {
	if x != nil {
		return x.Projects
	}
	return nil
}

type UpdateProjectReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" toml:"name,omitempty" mapstructure:"name,omitempty"`
	Id            string                 `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateProjectReq) Reset() {
	*x = UpdateProjectReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateProjectReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateProjectReq) ProtoMessage() {}

func (x *UpdateProjectReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateProjectReq.ProtoReflect.Descriptor instead.
func (*UpdateProjectReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{7}
}

func (x *UpdateProjectReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateProjectReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type UpdateProjectResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Project       *Project               `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty" toml:"project,omitempty" mapstructure:"project,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateProjectResp) Reset() {
	*x = UpdateProjectResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateProjectResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateProjectResp) ProtoMessage() {}

func (x *UpdateProjectResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateProjectResp.ProtoReflect.Descriptor instead.
func (*UpdateProjectResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{8}
}

func (x *UpdateProjectResp) GetProject() *Project {
	if x != nil {
		return x.Project
	}
	return nil
}

type DeleteProjectReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteProjectReq) Reset() {
	*x = DeleteProjectReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteProjectReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteProjectReq) ProtoMessage() {}

func (x *DeleteProjectReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteProjectReq.ProtoReflect.Descriptor instead.
func (*DeleteProjectReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{9}
}

func (x *DeleteProjectReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type DeleteProjectResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteProjectResp) Reset() {
	*x = DeleteProjectResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteProjectResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteProjectResp) ProtoMessage() {}

func (x *DeleteProjectResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteProjectResp.ProtoReflect.Descriptor instead.
func (*DeleteProjectResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{10}
}

type ApplyRulesStartReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesStartReq) Reset() {
	*x = ApplyRulesStartReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesStartReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesStartReq) ProtoMessage() {}

func (x *ApplyRulesStartReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesStartReq.ProtoReflect.Descriptor instead.
func (*ApplyRulesStartReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{11}
}

type ApplyRulesStartResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesStartResp) Reset() {
	*x = ApplyRulesStartResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesStartResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesStartResp) ProtoMessage() {}

func (x *ApplyRulesStartResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesStartResp.ProtoReflect.Descriptor instead.
func (*ApplyRulesStartResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{12}
}

type ApplyRulesCancelReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesCancelReq) Reset() {
	*x = ApplyRulesCancelReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesCancelReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesCancelReq) ProtoMessage() {}

func (x *ApplyRulesCancelReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesCancelReq.ProtoReflect.Descriptor instead.
func (*ApplyRulesCancelReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{13}
}

type ApplyRulesCancelResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesCancelResp) Reset() {
	*x = ApplyRulesCancelResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesCancelResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesCancelResp) ProtoMessage() {}

func (x *ApplyRulesCancelResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesCancelResp.ProtoReflect.Descriptor instead.
func (*ApplyRulesCancelResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{14}
}

type ApplyRulesStatusReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesStatusReq) Reset() {
	*x = ApplyRulesStatusReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesStatusReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesStatusReq) ProtoMessage() {}

func (x *ApplyRulesStatusReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesStatusReq.ProtoReflect.Descriptor instead.
func (*ApplyRulesStatusReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{15}
}

type ApplyRulesStatusResp struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	State                 string                 `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty" toml:"state,omitempty" mapstructure:"state,omitempty"`
	EstimatedTimeComplete *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=estimated_time_complete,json=estimatedTimeComplete,proto3" json:"estimated_time_complete,omitempty" toml:"estimated_time_complete,omitempty" mapstructure:"estimated_time_complete,omitempty"`
	PercentageComplete    float32                `protobuf:"fixed32,3,opt,name=percentage_complete,json=percentageComplete,proto3" json:"percentage_complete,omitempty" toml:"percentage_complete,omitempty" mapstructure:"percentage_complete,omitempty"`
	Failed                bool                   `protobuf:"varint,4,opt,name=failed,proto3" json:"failed,omitempty" toml:"failed,omitempty" mapstructure:"failed,omitempty"`
	FailureMessage        string                 `protobuf:"bytes,5,opt,name=failure_message,json=failureMessage,proto3" json:"failure_message,omitempty" toml:"failure_message,omitempty" mapstructure:"failure_message,omitempty"`
	Cancelled             bool                   `protobuf:"varint,6,opt,name=cancelled,proto3" json:"cancelled,omitempty" toml:"cancelled,omitempty" mapstructure:"cancelled,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *ApplyRulesStatusResp) Reset() {
	*x = ApplyRulesStatusResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesStatusResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesStatusResp) ProtoMessage() {}

func (x *ApplyRulesStatusResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesStatusResp.ProtoReflect.Descriptor instead.
func (*ApplyRulesStatusResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{16}
}

func (x *ApplyRulesStatusResp) GetState() string {
	if x != nil {
		return x.State
	}
	return ""
}

func (x *ApplyRulesStatusResp) GetEstimatedTimeComplete() *timestamppb.Timestamp {
	if x != nil {
		return x.EstimatedTimeComplete
	}
	return nil
}

func (x *ApplyRulesStatusResp) GetPercentageComplete() float32 {
	if x != nil {
		return x.PercentageComplete
	}
	return 0
}

func (x *ApplyRulesStatusResp) GetFailed() bool {
	if x != nil {
		return x.Failed
	}
	return false
}

func (x *ApplyRulesStatusResp) GetFailureMessage() string {
	if x != nil {
		return x.FailureMessage
	}
	return ""
}

func (x *ApplyRulesStatusResp) GetCancelled() bool {
	if x != nil {
		return x.Cancelled
	}
	return false
}

type ListRulesForAllProjectsReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRulesForAllProjectsReq) Reset() {
	*x = ListRulesForAllProjectsReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRulesForAllProjectsReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRulesForAllProjectsReq) ProtoMessage() {}

func (x *ListRulesForAllProjectsReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRulesForAllProjectsReq.ProtoReflect.Descriptor instead.
func (*ListRulesForAllProjectsReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{17}
}

type ListRulesForAllProjectsResp struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	ProjectRules  map[string]*ProjectRules `protobuf:"bytes,2,rep,name=project_rules,json=projectRules,proto3" json:"project_rules,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value" toml:"project_rules,omitempty" mapstructure:"project_rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRulesForAllProjectsResp) Reset() {
	*x = ListRulesForAllProjectsResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRulesForAllProjectsResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRulesForAllProjectsResp) ProtoMessage() {}

func (x *ListRulesForAllProjectsResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRulesForAllProjectsResp.ProtoReflect.Descriptor instead.
func (*ListRulesForAllProjectsResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{18}
}

func (x *ListRulesForAllProjectsResp) GetProjectRules() map[string]*ProjectRules {
	if x != nil {
		return x.ProjectRules
	}
	return nil
}

type ProjectRules struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*ProjectRule         `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty" toml:"rules,omitempty" mapstructure:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectRules) Reset() {
	*x = ProjectRules{}
	mi := &file_interservice_authz_project_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectRules) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectRules) ProtoMessage() {}

func (x *ProjectRules) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectRules.ProtoReflect.Descriptor instead.
func (*ProjectRules) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{19}
}

func (x *ProjectRules) GetRules() []*ProjectRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type ProjectRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	ProjectId     string                 `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty" toml:"project_id,omitempty" mapstructure:"project_id,omitempty"`
	Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" toml:"name,omitempty" mapstructure:"name,omitempty"`
	Type          ProjectRuleTypes       `protobuf:"varint,4,opt,name=type,proto3,enum=chef.automate.domain.authz.ProjectRuleTypes" json:"type,omitempty" toml:"type,omitempty" mapstructure:"type,omitempty"`
	Conditions    []*Condition           `protobuf:"bytes,5,rep,name=conditions,proto3" json:"conditions,omitempty" toml:"conditions,omitempty" mapstructure:"conditions,omitempty"`
	Deleted       bool                   `protobuf:"varint,6,opt,name=deleted,proto3" json:"deleted,omitempty" toml:"deleted,omitempty" mapstructure:"deleted,omitempty"`
	Status        string                 `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty" toml:"status,omitempty" mapstructure:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProjectRule) Reset() {
	*x = ProjectRule{}
	mi := &file_interservice_authz_project_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProjectRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProjectRule) ProtoMessage() {}

func (x *ProjectRule) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProjectRule.ProtoReflect.Descriptor instead.
func (*ProjectRule) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{20}
}

func (x *ProjectRule) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ProjectRule) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *ProjectRule) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ProjectRule) GetType() ProjectRuleTypes {
	if x != nil {
		return x.Type
	}
	return ProjectRuleTypes_NODE
}

func (x *ProjectRule) GetConditions() []*Condition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *ProjectRule) GetDeleted() bool {
	if x != nil {
		return x.Deleted
	}
	return false
}

func (x *ProjectRule) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type Condition struct {
	state         protoimpl.MessageState         `protogen:"open.v1"`
	Attribute     ProjectRuleConditionAttributes `protobuf:"varint,1,opt,name=attribute,proto3,enum=chef.automate.domain.authz.ProjectRuleConditionAttributes" json:"attribute,omitempty" toml:"attribute,omitempty" mapstructure:"attribute,omitempty"`
	Values        []string                       `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty" toml:"values,omitempty" mapstructure:"values,omitempty"`
	Operator      ProjectRuleConditionOperators  `protobuf:"varint,3,opt,name=operator,proto3,enum=chef.automate.domain.authz.ProjectRuleConditionOperators" json:"operator,omitempty" toml:"operator,omitempty" mapstructure:"operator,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Condition) Reset() {
	*x = Condition{}
	mi := &file_interservice_authz_project_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Condition) ProtoMessage() {}

func (x *Condition) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Condition.ProtoReflect.Descriptor instead.
func (*Condition) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{21}
}

func (x *Condition) GetAttribute() ProjectRuleConditionAttributes {
	if x != nil {
		return x.Attribute
	}
	return ProjectRuleConditionAttributes_CHEF_SERVER
}

func (x *Condition) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *Condition) GetOperator() ProjectRuleConditionOperators {
	if x != nil {
		return x.Operator
	}
	return ProjectRuleConditionOperators_MEMBER_OF
}

// CreateRuleReq is ProjectRule, so the input is just one JSON object. Also adds
// basic validation.
type CreateRuleReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	ProjectId     string                 `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty" toml:"project_id,omitempty" mapstructure:"project_id,omitempty"`
	Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" toml:"name,omitempty" mapstructure:"name,omitempty"`
	Type          ProjectRuleTypes       `protobuf:"varint,4,opt,name=type,proto3,enum=chef.automate.domain.authz.ProjectRuleTypes" json:"type,omitempty" toml:"type,omitempty" mapstructure:"type,omitempty"`
	Conditions    []*Condition           `protobuf:"bytes,5,rep,name=conditions,proto3" json:"conditions,omitempty" toml:"conditions,omitempty" mapstructure:"conditions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateRuleReq) Reset() {
	*x = CreateRuleReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateRuleReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateRuleReq) ProtoMessage() {}

func (x *CreateRuleReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateRuleReq.ProtoReflect.Descriptor instead.
func (*CreateRuleReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{22}
}

func (x *CreateRuleReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *CreateRuleReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *CreateRuleReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateRuleReq) GetType() ProjectRuleTypes {
	if x != nil {
		return x.Type
	}
	return ProjectRuleTypes_NODE
}

func (x *CreateRuleReq) GetConditions() []*Condition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

type CreateRuleResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rule          *ProjectRule           `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty" toml:"rule,omitempty" mapstructure:"rule,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateRuleResp) Reset() {
	*x = CreateRuleResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateRuleResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateRuleResp) ProtoMessage() {}

func (x *CreateRuleResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateRuleResp.ProtoReflect.Descriptor instead.
func (*CreateRuleResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{23}
}

func (x *CreateRuleResp) GetRule() *ProjectRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

type UpdateRuleReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	ProjectId     string                 `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty" toml:"project_id,omitempty" mapstructure:"project_id,omitempty"`
	Name          string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" toml:"name,omitempty" mapstructure:"name,omitempty"`
	Type          ProjectRuleTypes       `protobuf:"varint,4,opt,name=type,proto3,enum=chef.automate.domain.authz.ProjectRuleTypes" json:"type,omitempty" toml:"type,omitempty" mapstructure:"type,omitempty"`
	Conditions    []*Condition           `protobuf:"bytes,5,rep,name=conditions,proto3" json:"conditions,omitempty" toml:"conditions,omitempty" mapstructure:"conditions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateRuleReq) Reset() {
	*x = UpdateRuleReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateRuleReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateRuleReq) ProtoMessage() {}

func (x *UpdateRuleReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateRuleReq.ProtoReflect.Descriptor instead.
func (*UpdateRuleReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{24}
}

func (x *UpdateRuleReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *UpdateRuleReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

func (x *UpdateRuleReq) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateRuleReq) GetType() ProjectRuleTypes {
	if x != nil {
		return x.Type
	}
	return ProjectRuleTypes_NODE
}

func (x *UpdateRuleReq) GetConditions() []*Condition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

type UpdateRuleResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rule          *ProjectRule           `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty" toml:"rule,omitempty" mapstructure:"rule,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateRuleResp) Reset() {
	*x = UpdateRuleResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateRuleResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateRuleResp) ProtoMessage() {}

func (x *UpdateRuleResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateRuleResp.ProtoReflect.Descriptor instead.
func (*UpdateRuleResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{25}
}

func (x *UpdateRuleResp) GetRule() *ProjectRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

type GetRuleReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	ProjectId     string                 `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty" toml:"project_id,omitempty" mapstructure:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRuleReq) Reset() {
	*x = GetRuleReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRuleReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRuleReq) ProtoMessage() {}

func (x *GetRuleReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRuleReq.ProtoReflect.Descriptor instead.
func (*GetRuleReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{26}
}

func (x *GetRuleReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *GetRuleReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

type GetRuleResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rule          *ProjectRule           `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule,omitempty" toml:"rule,omitempty" mapstructure:"rule,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRuleResp) Reset() {
	*x = GetRuleResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRuleResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRuleResp) ProtoMessage() {}

func (x *GetRuleResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRuleResp.ProtoReflect.Descriptor instead.
func (*GetRuleResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{27}
}

func (x *GetRuleResp) GetRule() *ProjectRule {
	if x != nil {
		return x.Rule
	}
	return nil
}

type ListRulesReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IncludeStaged bool                   `protobuf:"varint,1,opt,name=include_staged,json=includeStaged,proto3" json:"include_staged,omitempty" toml:"include_staged,omitempty" mapstructure:"include_staged,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRulesReq) Reset() {
	*x = ListRulesReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRulesReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRulesReq) ProtoMessage() {}

func (x *ListRulesReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRulesReq.ProtoReflect.Descriptor instead.
func (*ListRulesReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{28}
}

func (x *ListRulesReq) GetIncludeStaged() bool {
	if x != nil {
		return x.IncludeStaged
	}
	return false
}

type ListRulesResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*ProjectRule         `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty" toml:"rules,omitempty" mapstructure:"rules,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRulesResp) Reset() {
	*x = ListRulesResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRulesResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRulesResp) ProtoMessage() {}

func (x *ListRulesResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRulesResp.ProtoReflect.Descriptor instead.
func (*ListRulesResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{29}
}

func (x *ListRulesResp) GetRules() []*ProjectRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

type ListRulesForProjectReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRulesForProjectReq) Reset() {
	*x = ListRulesForProjectReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRulesForProjectReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRulesForProjectReq) ProtoMessage() {}

func (x *ListRulesForProjectReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRulesForProjectReq.ProtoReflect.Descriptor instead.
func (*ListRulesForProjectReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{30}
}

func (x *ListRulesForProjectReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type ListRulesForProjectResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Rules         []*ProjectRule         `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty" toml:"rules,omitempty" mapstructure:"rules,omitempty"`
	Status        string                 `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty" toml:"status,omitempty" mapstructure:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRulesForProjectResp) Reset() {
	*x = ListRulesForProjectResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRulesForProjectResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRulesForProjectResp) ProtoMessage() {}

func (x *ListRulesForProjectResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRulesForProjectResp.ProtoReflect.Descriptor instead.
func (*ListRulesForProjectResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{31}
}

func (x *ListRulesForProjectResp) GetRules() []*ProjectRule {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *ListRulesForProjectResp) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type DeleteRuleReq struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" toml:"id,omitempty" mapstructure:"id,omitempty"`
	ProjectId     string                 `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty" toml:"project_id,omitempty" mapstructure:"project_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRuleReq) Reset() {
	*x = DeleteRuleReq{}
	mi := &file_interservice_authz_project_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRuleReq) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRuleReq) ProtoMessage() {}

func (x *DeleteRuleReq) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRuleReq.ProtoReflect.Descriptor instead.
func (*DeleteRuleReq) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{32}
}

func (x *DeleteRuleReq) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DeleteRuleReq) GetProjectId() string {
	if x != nil {
		return x.ProjectId
	}
	return ""
}

type DeleteRuleResp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRuleResp) Reset() {
	*x = DeleteRuleResp{}
	mi := &file_interservice_authz_project_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRuleResp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRuleResp) ProtoMessage() {}

func (x *DeleteRuleResp) ProtoReflect() protoreflect.Message {
	mi := &file_interservice_authz_project_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRuleResp.ProtoReflect.Descriptor instead.
func (*DeleteRuleResp) Descriptor() ([]byte, []int) {
	return file_interservice_authz_project_proto_rawDescGZIP(), []int{33}
}

var File_interservice_authz_project_proto protoreflect.FileDescriptor

const file_interservice_authz_project_proto_rawDesc = "" +
	"\n" +
	" interservice/authz/project.proto\x12\x1achef.automate.domain.authz\x1a\x17validate/validate.proto\x1a\x1dinterservice/authz/type.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"{\n" +
	"\aProject\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\x124\n" +
	"\x04type\x18\x03 \x01(\x0e2 .chef.automate.domain.authz.TypeR\x04type\x12\x16\n" +
	"\x06status\x18\x04 \x01(\tR\x06status\"v\n" +
	"\x10CreateProjectReq\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12)\n" +
	"\x02id\x18\x02 \x01(\tB\x19\xfaB\x16r\x142\x12^[a-z0-9-_]{1,48}$R\x02id\x12#\n" +
	"\rskip_policies\x18\x03 \x01(\bR\fskipPolicies\"R\n" +
	"\x11CreateProjectResp\x12=\n" +
	"\aproject\x18\x01 \x01(\v2#.chef.automate.domain.authz.ProjectR\aproject\"\x1f\n" +
	"\rGetProjectReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"O\n" +
	"\x0eGetProjectResp\x12=\n" +
	"\aproject\x18\x01 \x01(\v2#.chef.automate.domain.authz.ProjectR\aproject\"\x11\n" +
	"\x0fListProjectsReq\"S\n" +
	"\x10ListProjectsResp\x12?\n" +
	"\bprojects\x18\x01 \x03(\v2#.chef.automate.domain.authz.ProjectR\bprojects\"6\n" +
	"\x10UpdateProjectReq\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\tR\x02id\"R\n" +
	"\x11UpdateProjectResp\x12=\n" +
	"\aproject\x18\x01 \x01(\v2#.chef.automate.domain.authz.ProjectR\aproject\"\"\n" +
	"\x10DeleteProjectReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\x13\n" +
	"\x11DeleteProjectResp\"\x14\n" +
	"\x12ApplyRulesStartReq\"\x15\n" +
	"\x13ApplyRulesStartResp\"\x15\n" +
	"\x13ApplyRulesCancelReq\"\x16\n" +
	"\x14ApplyRulesCancelResp\"\x15\n" +
	"\x13ApplyRulesStatusReq\"\x90\x02\n" +
	"\x14ApplyRulesStatusResp\x12\x14\n" +
	"\x05state\x18\x01 \x01(\tR\x05state\x12R\n" +
	"\x17estimated_time_complete\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x15estimatedTimeComplete\x12/\n" +
	"\x13percentage_complete\x18\x03 \x01(\x02R\x12percentageComplete\x12\x16\n" +
	"\x06failed\x18\x04 \x01(\bR\x06failed\x12'\n" +
	"\x0ffailure_message\x18\x05 \x01(\tR\x0efailureMessage\x12\x1c\n" +
	"\tcancelled\x18\x06 \x01(\bR\tcancelled\"\x1c\n" +
	"\x1aListRulesForAllProjectsReq\"\xf8\x01\n" +
	"\x1bListRulesForAllProjectsResp\x12n\n" +
	"\rproject_rules\x18\x02 \x03(\v2I.chef.automate.domain.authz.ListRulesForAllProjectsResp.ProjectRulesEntryR\fprojectRules\x1ai\n" +
	"\x11ProjectRulesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12>\n" +
	"\x05value\x18\x02 \x01(\v2(.chef.automate.domain.authz.ProjectRulesR\x05value:\x028\x01\"M\n" +
	"\fProjectRules\x12=\n" +
	"\x05rules\x18\x02 \x03(\v2'.chef.automate.domain.authz.ProjectRuleR\x05rules\"\x8b\x02\n" +
	"\vProjectRule\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"project_id\x18\x02 \x01(\tR\tprojectId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12@\n" +
	"\x04type\x18\x04 \x01(\x0e2,.chef.automate.domain.authz.ProjectRuleTypesR\x04type\x12E\n" +
	"\n" +
	"conditions\x18\x05 \x03(\v2%.chef.automate.domain.authz.ConditionR\n" +
	"conditions\x12\x18\n" +
	"\adeleted\x18\x06 \x01(\bR\adeleted\x12\x16\n" +
	"\x06status\x18\a \x01(\tR\x06status\"\xd4\x01\n" +
	"\tCondition\x12X\n" +
	"\tattribute\x18\x01 \x01(\x0e2:.chef.automate.domain.authz.ProjectRuleConditionAttributesR\tattribute\x12\x16\n" +
	"\x06values\x18\x02 \x03(\tR\x06values\x12U\n" +
	"\boperator\x18\x03 \x01(\x0e29.chef.automate.domain.authz.ProjectRuleConditionOperatorsR\boperator\"\x80\x02\n" +
	"\rCreateRuleReq\x12)\n" +
	"\x02id\x18\x01 \x01(\tB\x19\xfaB\x16r\x142\x12^[a-z0-9-_]{1,64}$R\x02id\x12\x1d\n" +
	"\n" +
	"project_id\x18\x02 \x01(\tR\tprojectId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12@\n" +
	"\x04type\x18\x04 \x01(\x0e2,.chef.automate.domain.authz.ProjectRuleTypesR\x04type\x12O\n" +
	"\n" +
	"conditions\x18\x05 \x03(\v2%.chef.automate.domain.authz.ConditionB\b\xfaB\x05\x92\x01\x02\b\x01R\n" +
	"conditions\"M\n" +
	"\x0eCreateRuleResp\x12;\n" +
	"\x04rule\x18\x01 \x01(\v2'.chef.automate.domain.authz.ProjectRuleR\x04rule\"\xe5\x01\n" +
	"\rUpdateRuleReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"project_id\x18\x02 \x01(\tR\tprojectId\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12@\n" +
	"\x04type\x18\x04 \x01(\x0e2,.chef.automate.domain.authz.ProjectRuleTypesR\x04type\x12O\n" +
	"\n" +
	"conditions\x18\x05 \x03(\v2%.chef.automate.domain.authz.ConditionB\b\xfaB\x05\x92\x01\x02\b\x01R\n" +
	"conditions\"M\n" +
	"\x0eUpdateRuleResp\x12;\n" +
	"\x04rule\x18\x01 \x01(\v2'.chef.automate.domain.authz.ProjectRuleR\x04rule\";\n" +
	"\n" +
	"GetRuleReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"project_id\x18\x02 \x01(\tR\tprojectId\"J\n" +
	"\vGetRuleResp\x12;\n" +
	"\x04rule\x18\x01 \x01(\v2'.chef.automate.domain.authz.ProjectRuleR\x04rule\"5\n" +
	"\fListRulesReq\x12%\n" +
	"\x0einclude_staged\x18\x01 \x01(\bR\rincludeStaged\"N\n" +
	"\rListRulesResp\x12=\n" +
	"\x05rules\x18\x01 \x03(\v2'.chef.automate.domain.authz.ProjectRuleR\x05rules\"(\n" +
	"\x16ListRulesForProjectReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"p\n" +
	"\x17ListRulesForProjectResp\x12=\n" +
	"\x05rules\x18\x01 \x03(\v2'.chef.automate.domain.authz.ProjectRuleR\x05rules\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\">\n" +
	"\rDeleteRuleReq\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n" +
	"\n" +
	"project_id\x18\x02 \x01(\tR\tprojectId\"\x10\n" +
	"\x0eDeleteRuleResp*'\n" +
	"\x10ProjectRuleTypes\x12\b\n" +
	"\x04NODE\x10\x00\x12\t\n" +
	"\x05EVENT\x10\x01*\xa3\x01\n" +
	"\x1eProjectRuleConditionAttributes\x12\x0f\n" +
	"\vCHEF_SERVER\x10\x00\x12\x15\n" +
	"\x11CHEF_ORGANIZATION\x10\x01\x12\x0f\n" +
	"\vENVIRONMENT\x10\x02\x12\r\n" +
	"\tCHEF_ROLE\x10\x03\x12\f\n" +
	"\bCHEF_TAG\x10\x04\x12\x15\n" +
	"\x11CHEF_POLICY_GROUP\x10\x05\x12\x14\n" +
	"\x10CHEF_POLICY_NAME\x10\x06*:\n" +
	"\x1dProjectRuleConditionOperators\x12\r\n" +
	"\tMEMBER_OF\x10\x00\x12\n" +
	"\n" +
	"\x06EQUALS\x10\x012\x9f\x0e\n" +
	"\x0fProjectsService\x12n\n" +
	"\rUpdateProject\x12,.chef.automate.domain.authz.UpdateProjectReq\x1a-.chef.automate.domain.authz.UpdateProjectResp\"\x00\x12n\n" +
	"\rCreateProject\x12,.chef.automate.domain.authz.CreateProjectReq\x1a-.chef.automate.domain.authz.CreateProjectResp\"\x00\x12e\n" +
	"\n" +
	"GetProject\x12).chef.automate.domain.authz.GetProjectReq\x1a*.chef.automate.domain.authz.GetProjectResp\"\x00\x12n\n" +
	"\rDeleteProject\x12,.chef.automate.domain.authz.DeleteProjectReq\x1a-.chef.automate.domain.authz.DeleteProjectResp\"\x00\x12k\n" +
	"\fListProjects\x12+.chef.automate.domain.authz.ListProjectsReq\x1a,.chef.automate.domain.authz.ListProjectsResp\"\x00\x12{\n" +
	"\x1cListProjectsForIntrospection\x12+.chef.automate.domain.authz.ListProjectsReq\x1a,.chef.automate.domain.authz.ListProjectsResp\"\x00\x12t\n" +
	"\x0fApplyRulesStart\x12..chef.automate.domain.authz.ApplyRulesStartReq\x1a/.chef.automate.domain.authz.ApplyRulesStartResp\"\x00\x12u\n" +
	"\x10ApplyRulesCancel\x12/.chef.automate.domain.authz.ApplyRulesCancelReq\x1a0.chef.automate.domain.authz.ApplyRulesCancelResp\x12u\n" +
	"\x10ApplyRulesStatus\x12/.chef.automate.domain.authz.ApplyRulesStatusReq\x1a0.chef.automate.domain.authz.ApplyRulesStatusResp\x12e\n" +
	"\n" +
	"CreateRule\x12).chef.automate.domain.authz.CreateRuleReq\x1a*.chef.automate.domain.authz.CreateRuleResp\"\x00\x12e\n" +
	"\n" +
	"UpdateRule\x12).chef.automate.domain.authz.UpdateRuleReq\x1a*.chef.automate.domain.authz.UpdateRuleResp\"\x00\x12\\\n" +
	"\aGetRule\x12&.chef.automate.domain.authz.GetRuleReq\x1a'.chef.automate.domain.authz.GetRuleResp\"\x00\x12b\n" +
	"\tListRules\x12(.chef.automate.domain.authz.ListRulesReq\x1a).chef.automate.domain.authz.ListRulesResp\"\x00\x12\x80\x01\n" +
	"\x13ListRulesForProject\x122.chef.automate.domain.authz.ListRulesForProjectReq\x1a3.chef.automate.domain.authz.ListRulesForProjectResp\"\x00\x12e\n" +
	"\n" +
	"DeleteRule\x12).chef.automate.domain.authz.DeleteRuleReq\x1a*.chef.automate.domain.authz.DeleteRuleResp\"\x00\x12\x8c\x01\n" +
	"\x17ListRulesForAllProjects\x126.chef.automate.domain.authz.ListRulesForAllProjectsReq\x1a7.chef.automate.domain.authz.ListRulesForAllProjectsResp\"\x00B1Z/github.com/chef/automate/api/interservice/authzb\x06proto3"

var (
	file_interservice_authz_project_proto_rawDescOnce sync.Once
	file_interservice_authz_project_proto_rawDescData []byte
)

func file_interservice_authz_project_proto_rawDescGZIP() []byte {
	file_interservice_authz_project_proto_rawDescOnce.Do(func() {
		file_interservice_authz_project_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_interservice_authz_project_proto_rawDesc), len(file_interservice_authz_project_proto_rawDesc)))
	})
	return file_interservice_authz_project_proto_rawDescData
}

var file_interservice_authz_project_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_interservice_authz_project_proto_msgTypes = make([]protoimpl.MessageInfo, 35)
var file_interservice_authz_project_proto_goTypes = []any{
	(ProjectRuleTypes)(0),               // 0: chef.automate.domain.authz.ProjectRuleTypes
	(ProjectRuleConditionAttributes)(0), // 1: chef.automate.domain.authz.ProjectRuleConditionAttributes
	(ProjectRuleConditionOperators)(0),  // 2: chef.automate.domain.authz.ProjectRuleConditionOperators
	(*Project)(nil),                     // 3: chef.automate.domain.authz.Project
	(*CreateProjectReq)(nil),            // 4: chef.automate.domain.authz.CreateProjectReq
	(*CreateProjectResp)(nil),           // 5: chef.automate.domain.authz.CreateProjectResp
	(*GetProjectReq)(nil),               // 6: chef.automate.domain.authz.GetProjectReq
	(*GetProjectResp)(nil),              // 7: chef.automate.domain.authz.GetProjectResp
	(*ListProjectsReq)(nil),             // 8: chef.automate.domain.authz.ListProjectsReq
	(*ListProjectsResp)(nil),            // 9: chef.automate.domain.authz.ListProjectsResp
	(*UpdateProjectReq)(nil),            // 10: chef.automate.domain.authz.UpdateProjectReq
	(*UpdateProjectResp)(nil),           // 11: chef.automate.domain.authz.UpdateProjectResp
	(*DeleteProjectReq)(nil),            // 12: chef.automate.domain.authz.DeleteProjectReq
	(*DeleteProjectResp)(nil),           // 13: chef.automate.domain.authz.DeleteProjectResp
	(*ApplyRulesStartReq)(nil),          // 14: chef.automate.domain.authz.ApplyRulesStartReq
	(*ApplyRulesStartResp)(nil),         // 15: chef.automate.domain.authz.ApplyRulesStartResp
	(*ApplyRulesCancelReq)(nil),         // 16: chef.automate.domain.authz.ApplyRulesCancelReq
	(*ApplyRulesCancelResp)(nil),        // 17: chef.automate.domain.authz.ApplyRulesCancelResp
	(*ApplyRulesStatusReq)(nil),         // 18: chef.automate.domain.authz.ApplyRulesStatusReq
	(*ApplyRulesStatusResp)(nil),        // 19: chef.automate.domain.authz.ApplyRulesStatusResp
	(*ListRulesForAllProjectsReq)(nil),  // 20: chef.automate.domain.authz.ListRulesForAllProjectsReq
	(*ListRulesForAllProjectsResp)(nil), // 21: chef.automate.domain.authz.ListRulesForAllProjectsResp
	(*ProjectRules)(nil),                // 22: chef.automate.domain.authz.ProjectRules
	(*ProjectRule)(nil),                 // 23: chef.automate.domain.authz.ProjectRule
	(*Condition)(nil),                   // 24: chef.automate.domain.authz.Condition
	(*CreateRuleReq)(nil),               // 25: chef.automate.domain.authz.CreateRuleReq
	(*CreateRuleResp)(nil),              // 26: chef.automate.domain.authz.CreateRuleResp
	(*UpdateRuleReq)(nil),               // 27: chef.automate.domain.authz.UpdateRuleReq
	(*UpdateRuleResp)(nil),              // 28: chef.automate.domain.authz.UpdateRuleResp
	(*GetRuleReq)(nil),                  // 29: chef.automate.domain.authz.GetRuleReq
	(*GetRuleResp)(nil),                 // 30: chef.automate.domain.authz.GetRuleResp
	(*ListRulesReq)(nil),                // 31: chef.automate.domain.authz.ListRulesReq
	(*ListRulesResp)(nil),               // 32: chef.automate.domain.authz.ListRulesResp
	(*ListRulesForProjectReq)(nil),      // 33: chef.automate.domain.authz.ListRulesForProjectReq
	(*ListRulesForProjectResp)(nil),     // 34: chef.automate.domain.authz.ListRulesForProjectResp
	(*DeleteRuleReq)(nil),               // 35: chef.automate.domain.authz.DeleteRuleReq
	(*DeleteRuleResp)(nil),              // 36: chef.automate.domain.authz.DeleteRuleResp
	nil,                                 // 37: chef.automate.domain.authz.ListRulesForAllProjectsResp.ProjectRulesEntry
	(Type)(0),                           // 38: chef.automate.domain.authz.Type
	(*timestamppb.Timestamp)(nil),       // 39: google.protobuf.Timestamp
}
var file_interservice_authz_project_proto_depIdxs = []int32{
	38, // 0: chef.automate.domain.authz.Project.type:type_name -> chef.automate.domain.authz.Type
	3,  // 1: chef.automate.domain.authz.CreateProjectResp.project:type_name -> chef.automate.domain.authz.Project
	3,  // 2: chef.automate.domain.authz.GetProjectResp.project:type_name -> chef.automate.domain.authz.Project
	3,  // 3: chef.automate.domain.authz.ListProjectsResp.projects:type_name -> chef.automate.domain.authz.Project
	3,  // 4: chef.automate.domain.authz.UpdateProjectResp.project:type_name -> chef.automate.domain.authz.Project
	39, // 5: chef.automate.domain.authz.ApplyRulesStatusResp.estimated_time_complete:type_name -> google.protobuf.Timestamp
	37, // 6: chef.automate.domain.authz.ListRulesForAllProjectsResp.project_rules:type_name -> chef.automate.domain.authz.ListRulesForAllProjectsResp.ProjectRulesEntry
	23, // 7: chef.automate.domain.authz.ProjectRules.rules:type_name -> chef.automate.domain.authz.ProjectRule
	0,  // 8: chef.automate.domain.authz.ProjectRule.type:type_name -> chef.automate.domain.authz.ProjectRuleTypes
	24, // 9: chef.automate.domain.authz.ProjectRule.conditions:type_name -> chef.automate.domain.authz.Condition
	1,  // 10: chef.automate.domain.authz.Condition.attribute:type_name -> chef.automate.domain.authz.ProjectRuleConditionAttributes
	2,  // 11: chef.automate.domain.authz.Condition.operator:type_name -> chef.automate.domain.authz.ProjectRuleConditionOperators
	0,  // 12: chef.automate.domain.authz.CreateRuleReq.type:type_name -> chef.automate.domain.authz.ProjectRuleTypes
	24, // 13: chef.automate.domain.authz.CreateRuleReq.conditions:type_name -> chef.automate.domain.authz.Condition
	23, // 14: chef.automate.domain.authz.CreateRuleResp.rule:type_name -> chef.automate.domain.authz.ProjectRule
	0,  // 15: chef.automate.domain.authz.UpdateRuleReq.type:type_name -> chef.automate.domain.authz.ProjectRuleTypes
	24, // 16: chef.automate.domain.authz.UpdateRuleReq.conditions:type_name -> chef.automate.domain.authz.Condition
	23, // 17: chef.automate.domain.authz.UpdateRuleResp.rule:type_name -> chef.automate.domain.authz.ProjectRule
	23, // 18: chef.automate.domain.authz.GetRuleResp.rule:type_name -> chef.automate.domain.authz.ProjectRule
	23, // 19: chef.automate.domain.authz.ListRulesResp.rules:type_name -> chef.automate.domain.authz.ProjectRule
	23, // 20: chef.automate.domain.authz.ListRulesForProjectResp.rules:type_name -> chef.automate.domain.authz.ProjectRule
	22, // 21: chef.automate.domain.authz.ListRulesForAllProjectsResp.ProjectRulesEntry.value:type_name -> chef.automate.domain.authz.ProjectRules
	10, // 22: chef.automate.domain.authz.ProjectsService.UpdateProject:input_type -> chef.automate.domain.authz.UpdateProjectReq
	4,  // 23: chef.automate.domain.authz.ProjectsService.CreateProject:input_type -> chef.automate.domain.authz.CreateProjectReq
	6,  // 24: chef.automate.domain.authz.ProjectsService.GetProject:input_type -> chef.automate.domain.authz.GetProjectReq
	12, // 25: chef.automate.domain.authz.ProjectsService.DeleteProject:input_type -> chef.automate.domain.authz.DeleteProjectReq
	8,  // 26: chef.automate.domain.authz.ProjectsService.ListProjects:input_type -> chef.automate.domain.authz.ListProjectsReq
	8,  // 27: chef.automate.domain.authz.ProjectsService.ListProjectsForIntrospection:input_type -> chef.automate.domain.authz.ListProjectsReq
	14, // 28: chef.automate.domain.authz.ProjectsService.ApplyRulesStart:input_type -> chef.automate.domain.authz.ApplyRulesStartReq
	16, // 29: chef.automate.domain.authz.ProjectsService.ApplyRulesCancel:input_type -> chef.automate.domain.authz.ApplyRulesCancelReq
	18, // 30: chef.automate.domain.authz.ProjectsService.ApplyRulesStatus:input_type -> chef.automate.domain.authz.ApplyRulesStatusReq
	25, // 31: chef.automate.domain.authz.ProjectsService.CreateRule:input_type -> chef.automate.domain.authz.CreateRuleReq
	27, // 32: chef.automate.domain.authz.ProjectsService.UpdateRule:input_type -> chef.automate.domain.authz.UpdateRuleReq
	29, // 33: chef.automate.domain.authz.ProjectsService.GetRule:input_type -> chef.automate.domain.authz.GetRuleReq
	31, // 34: chef.automate.domain.authz.ProjectsService.ListRules:input_type -> chef.automate.domain.authz.ListRulesReq
	33, // 35: chef.automate.domain.authz.ProjectsService.ListRulesForProject:input_type -> chef.automate.domain.authz.ListRulesForProjectReq
	35, // 36: chef.automate.domain.authz.ProjectsService.DeleteRule:input_type -> chef.automate.domain.authz.DeleteRuleReq
	20, // 37: chef.automate.domain.authz.ProjectsService.ListRulesForAllProjects:input_type -> chef.automate.domain.authz.ListRulesForAllProjectsReq
	11, // 38: chef.automate.domain.authz.ProjectsService.UpdateProject:output_type -> chef.automate.domain.authz.UpdateProjectResp
	5,  // 39: chef.automate.domain.authz.ProjectsService.CreateProject:output_type -> chef.automate.domain.authz.CreateProjectResp
	7,  // 40: chef.automate.domain.authz.ProjectsService.GetProject:output_type -> chef.automate.domain.authz.GetProjectResp
	13, // 41: chef.automate.domain.authz.ProjectsService.DeleteProject:output_type -> chef.automate.domain.authz.DeleteProjectResp
	9,  // 42: chef.automate.domain.authz.ProjectsService.ListProjects:output_type -> chef.automate.domain.authz.ListProjectsResp
	9,  // 43: chef.automate.domain.authz.ProjectsService.ListProjectsForIntrospection:output_type -> chef.automate.domain.authz.ListProjectsResp
	15, // 44: chef.automate.domain.authz.ProjectsService.ApplyRulesStart:output_type -> chef.automate.domain.authz.ApplyRulesStartResp
	17, // 45: chef.automate.domain.authz.ProjectsService.ApplyRulesCancel:output_type -> chef.automate.domain.authz.ApplyRulesCancelResp
	19, // 46: chef.automate.domain.authz.ProjectsService.ApplyRulesStatus:output_type -> chef.automate.domain.authz.ApplyRulesStatusResp
	26, // 47: chef.automate.domain.authz.ProjectsService.CreateRule:output_type -> chef.automate.domain.authz.CreateRuleResp
	28, // 48: chef.automate.domain.authz.ProjectsService.UpdateRule:output_type -> chef.automate.domain.authz.UpdateRuleResp
	30, // 49: chef.automate.domain.authz.ProjectsService.GetRule:output_type -> chef.automate.domain.authz.GetRuleResp
	32, // 50: chef.automate.domain.authz.ProjectsService.ListRules:output_type -> chef.automate.domain.authz.ListRulesResp
	34, // 51: chef.automate.domain.authz.ProjectsService.ListRulesForProject:output_type -> chef.automate.domain.authz.ListRulesForProjectResp
	36, // 52: chef.automate.domain.authz.ProjectsService.DeleteRule:output_type -> chef.automate.domain.authz.DeleteRuleResp
	21, // 53: chef.automate.domain.authz.ProjectsService.ListRulesForAllProjects:output_type -> chef.automate.domain.authz.ListRulesForAllProjectsResp
	38, // [38:54] is the sub-list for method output_type
	22, // [22:38] is the sub-list for method input_type
	22, // [22:22] is the sub-list for extension type_name
	22, // [22:22] is the sub-list for extension extendee
	0,  // [0:22] is the sub-list for field type_name
}

func init() { file_interservice_authz_project_proto_init() }
func file_interservice_authz_project_proto_init() {
	if File_interservice_authz_project_proto != nil {
		return
	}
	file_interservice_authz_type_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_interservice_authz_project_proto_rawDesc), len(file_interservice_authz_project_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   35,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_interservice_authz_project_proto_goTypes,
		DependencyIndexes: file_interservice_authz_project_proto_depIdxs,
		EnumInfos:         file_interservice_authz_project_proto_enumTypes,
		MessageInfos:      file_interservice_authz_project_proto_msgTypes,
	}.Build()
	File_interservice_authz_project_proto = out.File
	file_interservice_authz_project_proto_goTypes = nil
	file_interservice_authz_project_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ProjectsServiceClient is the client API for ProjectsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ProjectsServiceClient interface {
	UpdateProject(ctx context.Context, in *UpdateProjectReq, opts ...grpc.CallOption) (*UpdateProjectResp, error)
	CreateProject(ctx context.Context, in *CreateProjectReq, opts ...grpc.CallOption) (*CreateProjectResp, error)
	GetProject(ctx context.Context, in *GetProjectReq, opts ...grpc.CallOption) (*GetProjectResp, error)
	DeleteProject(ctx context.Context, in *DeleteProjectReq, opts ...grpc.CallOption) (*DeleteProjectResp, error)
	ListProjects(ctx context.Context, in *ListProjectsReq, opts ...grpc.CallOption) (*ListProjectsResp, error)
	ListProjectsForIntrospection(ctx context.Context, in *ListProjectsReq, opts ...grpc.CallOption) (*ListProjectsResp, error)
	ApplyRulesStart(ctx context.Context, in *ApplyRulesStartReq, opts ...grpc.CallOption) (*ApplyRulesStartResp, error)
	ApplyRulesCancel(ctx context.Context, in *ApplyRulesCancelReq, opts ...grpc.CallOption) (*ApplyRulesCancelResp, error)
	ApplyRulesStatus(ctx context.Context, in *ApplyRulesStatusReq, opts ...grpc.CallOption) (*ApplyRulesStatusResp, error)
	// "proper" methods go here (and the ones above will be phased out eventually)
	CreateRule(ctx context.Context, in *CreateRuleReq, opts ...grpc.CallOption) (*CreateRuleResp, error)
	UpdateRule(ctx context.Context, in *UpdateRuleReq, opts ...grpc.CallOption) (*UpdateRuleResp, error)
	GetRule(ctx context.Context, in *GetRuleReq, opts ...grpc.CallOption) (*GetRuleResp, error)
	ListRules(ctx context.Context, in *ListRulesReq, opts ...grpc.CallOption) (*ListRulesResp, error)
	ListRulesForProject(ctx context.Context, in *ListRulesForProjectReq, opts ...grpc.CallOption) (*ListRulesForProjectResp, error)
	DeleteRule(ctx context.Context, in *DeleteRuleReq, opts ...grpc.CallOption) (*DeleteRuleResp, error)
	ListRulesForAllProjects(ctx context.Context, in *ListRulesForAllProjectsReq, opts ...grpc.CallOption) (*ListRulesForAllProjectsResp, error)
}

type projectsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectsServiceClient(cc grpc.ClientConnInterface) ProjectsServiceClient {
	return &projectsServiceClient{cc}
}

func (c *projectsServiceClient) UpdateProject(ctx context.Context, in *UpdateProjectReq, opts ...grpc.CallOption) (*UpdateProjectResp, error) {
	out := new(UpdateProjectResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/UpdateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) CreateProject(ctx context.Context, in *CreateProjectReq, opts ...grpc.CallOption) (*CreateProjectResp, error) {
	out := new(CreateProjectResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) GetProject(ctx context.Context, in *GetProjectReq, opts ...grpc.CallOption) (*GetProjectResp, error) {
	out := new(GetProjectResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/GetProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) DeleteProject(ctx context.Context, in *DeleteProjectReq, opts ...grpc.CallOption) (*DeleteProjectResp, error) {
	out := new(DeleteProjectResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/DeleteProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ListProjects(ctx context.Context, in *ListProjectsReq, opts ...grpc.CallOption) (*ListProjectsResp, error) {
	out := new(ListProjectsResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ListProjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ListProjectsForIntrospection(ctx context.Context, in *ListProjectsReq, opts ...grpc.CallOption) (*ListProjectsResp, error) {
	out := new(ListProjectsResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ListProjectsForIntrospection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ApplyRulesStart(ctx context.Context, in *ApplyRulesStartReq, opts ...grpc.CallOption) (*ApplyRulesStartResp, error) {
	out := new(ApplyRulesStartResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ApplyRulesStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ApplyRulesCancel(ctx context.Context, in *ApplyRulesCancelReq, opts ...grpc.CallOption) (*ApplyRulesCancelResp, error) {
	out := new(ApplyRulesCancelResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ApplyRulesCancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ApplyRulesStatus(ctx context.Context, in *ApplyRulesStatusReq, opts ...grpc.CallOption) (*ApplyRulesStatusResp, error) {
	out := new(ApplyRulesStatusResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ApplyRulesStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) CreateRule(ctx context.Context, in *CreateRuleReq, opts ...grpc.CallOption) (*CreateRuleResp, error) {
	out := new(CreateRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/CreateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) UpdateRule(ctx context.Context, in *UpdateRuleReq, opts ...grpc.CallOption) (*UpdateRuleResp, error) {
	out := new(UpdateRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/UpdateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) GetRule(ctx context.Context, in *GetRuleReq, opts ...grpc.CallOption) (*GetRuleResp, error) {
	out := new(GetRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/GetRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ListRules(ctx context.Context, in *ListRulesReq, opts ...grpc.CallOption) (*ListRulesResp, error) {
	out := new(ListRulesResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ListRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ListRulesForProject(ctx context.Context, in *ListRulesForProjectReq, opts ...grpc.CallOption) (*ListRulesForProjectResp, error) {
	out := new(ListRulesForProjectResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ListRulesForProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) DeleteRule(ctx context.Context, in *DeleteRuleReq, opts ...grpc.CallOption) (*DeleteRuleResp, error) {
	out := new(DeleteRuleResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/DeleteRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsServiceClient) ListRulesForAllProjects(ctx context.Context, in *ListRulesForAllProjectsReq, opts ...grpc.CallOption) (*ListRulesForAllProjectsResp, error) {
	out := new(ListRulesForAllProjectsResp)
	err := c.cc.Invoke(ctx, "/chef.automate.domain.authz.ProjectsService/ListRulesForAllProjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectsServiceServer is the server API for ProjectsService service.
type ProjectsServiceServer interface {
	UpdateProject(context.Context, *UpdateProjectReq) (*UpdateProjectResp, error)
	CreateProject(context.Context, *CreateProjectReq) (*CreateProjectResp, error)
	GetProject(context.Context, *GetProjectReq) (*GetProjectResp, error)
	DeleteProject(context.Context, *DeleteProjectReq) (*DeleteProjectResp, error)
	ListProjects(context.Context, *ListProjectsReq) (*ListProjectsResp, error)
	ListProjectsForIntrospection(context.Context, *ListProjectsReq) (*ListProjectsResp, error)
	ApplyRulesStart(context.Context, *ApplyRulesStartReq) (*ApplyRulesStartResp, error)
	ApplyRulesCancel(context.Context, *ApplyRulesCancelReq) (*ApplyRulesCancelResp, error)
	ApplyRulesStatus(context.Context, *ApplyRulesStatusReq) (*ApplyRulesStatusResp, error)
	// "proper" methods go here (and the ones above will be phased out eventually)
	CreateRule(context.Context, *CreateRuleReq) (*CreateRuleResp, error)
	UpdateRule(context.Context, *UpdateRuleReq) (*UpdateRuleResp, error)
	GetRule(context.Context, *GetRuleReq) (*GetRuleResp, error)
	ListRules(context.Context, *ListRulesReq) (*ListRulesResp, error)
	ListRulesForProject(context.Context, *ListRulesForProjectReq) (*ListRulesForProjectResp, error)
	DeleteRule(context.Context, *DeleteRuleReq) (*DeleteRuleResp, error)
	ListRulesForAllProjects(context.Context, *ListRulesForAllProjectsReq) (*ListRulesForAllProjectsResp, error)
}

// UnimplementedProjectsServiceServer can be embedded to have forward compatible implementations.
type UnimplementedProjectsServiceServer struct {
}

func (*UnimplementedProjectsServiceServer) UpdateProject(context.Context, *UpdateProjectReq) (*UpdateProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (*UnimplementedProjectsServiceServer) CreateProject(context.Context, *CreateProjectReq) (*CreateProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (*UnimplementedProjectsServiceServer) GetProject(context.Context, *GetProjectReq) (*GetProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProject not implemented")
}
func (*UnimplementedProjectsServiceServer) DeleteProject(context.Context, *DeleteProjectReq) (*DeleteProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (*UnimplementedProjectsServiceServer) ListProjects(context.Context, *ListProjectsReq) (*ListProjectsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjects not implemented")
}
func (*UnimplementedProjectsServiceServer) ListProjectsForIntrospection(context.Context, *ListProjectsReq) (*ListProjectsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjectsForIntrospection not implemented")
}
func (*UnimplementedProjectsServiceServer) ApplyRulesStart(context.Context, *ApplyRulesStartReq) (*ApplyRulesStartResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRulesStart not implemented")
}
func (*UnimplementedProjectsServiceServer) ApplyRulesCancel(context.Context, *ApplyRulesCancelReq) (*ApplyRulesCancelResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRulesCancel not implemented")
}
func (*UnimplementedProjectsServiceServer) ApplyRulesStatus(context.Context, *ApplyRulesStatusReq) (*ApplyRulesStatusResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyRulesStatus not implemented")
}
func (*UnimplementedProjectsServiceServer) CreateRule(context.Context, *CreateRuleReq) (*CreateRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRule not implemented")
}
func (*UnimplementedProjectsServiceServer) UpdateRule(context.Context, *UpdateRuleReq) (*UpdateRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRule not implemented")
}
func (*UnimplementedProjectsServiceServer) GetRule(context.Context, *GetRuleReq) (*GetRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (*UnimplementedProjectsServiceServer) ListRules(context.Context, *ListRulesReq) (*ListRulesResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRules not implemented")
}
func (*UnimplementedProjectsServiceServer) ListRulesForProject(context.Context, *ListRulesForProjectReq) (*ListRulesForProjectResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRulesForProject not implemented")
}
func (*UnimplementedProjectsServiceServer) DeleteRule(context.Context, *DeleteRuleReq) (*DeleteRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRule not implemented")
}
func (*UnimplementedProjectsServiceServer) ListRulesForAllProjects(context.Context, *ListRulesForAllProjectsReq) (*ListRulesForAllProjectsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRulesForAllProjects not implemented")
}

func RegisterProjectsServiceServer(s *grpc.Server, srv ProjectsServiceServer) {
	s.RegisterService(&_ProjectsService_serviceDesc, srv)
}

func _ProjectsService_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/UpdateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).UpdateProject(ctx, req.(*UpdateProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).CreateProject(ctx, req.(*CreateProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_GetProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).GetProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/GetProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).GetProject(ctx, req.(*GetProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/DeleteProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).DeleteProject(ctx, req.(*DeleteProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ListProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ListProjects(ctx, req.(*ListProjectsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ListProjectsForIntrospection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ListProjectsForIntrospection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ListProjectsForIntrospection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ListProjectsForIntrospection(ctx, req.(*ListProjectsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ApplyRulesStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRulesStartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ApplyRulesStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ApplyRulesStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ApplyRulesStart(ctx, req.(*ApplyRulesStartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ApplyRulesCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRulesCancelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ApplyRulesCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ApplyRulesCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ApplyRulesCancel(ctx, req.(*ApplyRulesCancelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ApplyRulesStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRulesStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ApplyRulesStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ApplyRulesStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ApplyRulesStatus(ctx, req.(*ApplyRulesStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_CreateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).CreateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/CreateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).CreateRule(ctx, req.(*CreateRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/UpdateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).UpdateRule(ctx, req.(*UpdateRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/GetRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).GetRule(ctx, req.(*GetRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRulesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ListRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ListRules(ctx, req.(*ListRulesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ListRulesForProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRulesForProjectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ListRulesForProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ListRulesForProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ListRulesForProject(ctx, req.(*ListRulesForProjectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_DeleteRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).DeleteRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/DeleteRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).DeleteRule(ctx, req.(*DeleteRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectsService_ListRulesForAllProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRulesForAllProjectsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServiceServer).ListRulesForAllProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/chef.automate.domain.authz.ProjectsService/ListRulesForAllProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServiceServer).ListRulesForAllProjects(ctx, req.(*ListRulesForAllProjectsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ProjectsService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "chef.automate.domain.authz.ProjectsService",
	HandlerType: (*ProjectsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateProject",
			Handler:    _ProjectsService_UpdateProject_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _ProjectsService_CreateProject_Handler,
		},
		{
			MethodName: "GetProject",
			Handler:    _ProjectsService_GetProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _ProjectsService_DeleteProject_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _ProjectsService_ListProjects_Handler,
		},
		{
			MethodName: "ListProjectsForIntrospection",
			Handler:    _ProjectsService_ListProjectsForIntrospection_Handler,
		},
		{
			MethodName: "ApplyRulesStart",
			Handler:    _ProjectsService_ApplyRulesStart_Handler,
		},
		{
			MethodName: "ApplyRulesCancel",
			Handler:    _ProjectsService_ApplyRulesCancel_Handler,
		},
		{
			MethodName: "ApplyRulesStatus",
			Handler:    _ProjectsService_ApplyRulesStatus_Handler,
		},
		{
			MethodName: "CreateRule",
			Handler:    _ProjectsService_CreateRule_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _ProjectsService_UpdateRule_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _ProjectsService_GetRule_Handler,
		},
		{
			MethodName: "ListRules",
			Handler:    _ProjectsService_ListRules_Handler,
		},
		{
			MethodName: "ListRulesForProject",
			Handler:    _ProjectsService_ListRulesForProject_Handler,
		},
		{
			MethodName: "DeleteRule",
			Handler:    _ProjectsService_DeleteRule_Handler,
		},
		{
			MethodName: "ListRulesForAllProjects",
			Handler:    _ProjectsService_ListRulesForAllProjects_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "interservice/authz/project.proto",
}
