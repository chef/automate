// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: interservice/authz/project.proto

package authz

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProjectMultiError, or nil if none found.
func (m *Project) ValidateAll() error {
	return m.validate(true)
}

func (m *Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Status

	if len(errors) > 0 {
		return ProjectMultiError(errors)
	}

	return nil
}

// ProjectMultiError is an error wrapping multiple validation errors returned
// by Project.ValidateAll() if the designated constraints aren't met.
type ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectMultiError) AllErrors() []error { return m }

// ProjectValidationError is the validation error returned by Project.Validate
// if the designated constraints aren't met.
type ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectValidationError) ErrorName() string { return "ProjectValidationError" }

// Error satisfies the builtin error interface
func (e ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectValidationError{}

// Validate checks the field values on CreateProjectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectReqMultiError, or nil if none found.
func (m *CreateProjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if !_CreateProjectReq_Id_Pattern.MatchString(m.GetId()) {
		err := CreateProjectReqValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[a-z0-9-_]{1,48}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for SkipPolicies

	if len(errors) > 0 {
		return CreateProjectReqMultiError(errors)
	}

	return nil
}

// CreateProjectReqMultiError is an error wrapping multiple validation errors
// returned by CreateProjectReq.ValidateAll() if the designated constraints
// aren't met.
type CreateProjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectReqMultiError) AllErrors() []error { return m }

// CreateProjectReqValidationError is the validation error returned by
// CreateProjectReq.Validate if the designated constraints aren't met.
type CreateProjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectReqValidationError) ErrorName() string { return "CreateProjectReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateProjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectReqValidationError{}

var _CreateProjectReq_Id_Pattern = regexp.MustCompile("^[a-z0-9-_]{1,48}$")

// Validate checks the field values on CreateProjectResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectRespMultiError, or nil if none found.
func (m *CreateProjectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProjectRespValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProjectRespValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProjectRespValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateProjectRespMultiError(errors)
	}

	return nil
}

// CreateProjectRespMultiError is an error wrapping multiple validation errors
// returned by CreateProjectResp.ValidateAll() if the designated constraints
// aren't met.
type CreateProjectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectRespMultiError) AllErrors() []error { return m }

// CreateProjectRespValidationError is the validation error returned by
// CreateProjectResp.Validate if the designated constraints aren't met.
type CreateProjectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectRespValidationError) ErrorName() string {
	return "CreateProjectRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProjectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectRespValidationError{}

// Validate checks the field values on GetProjectReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetProjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetProjectReqMultiError, or
// nil if none found.
func (m *GetProjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetProjectReqMultiError(errors)
	}

	return nil
}

// GetProjectReqMultiError is an error wrapping multiple validation errors
// returned by GetProjectReq.ValidateAll() if the designated constraints
// aren't met.
type GetProjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectReqMultiError) AllErrors() []error { return m }

// GetProjectReqValidationError is the validation error returned by
// GetProjectReq.Validate if the designated constraints aren't met.
type GetProjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectReqValidationError) ErrorName() string { return "GetProjectReqValidationError" }

// Error satisfies the builtin error interface
func (e GetProjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectReqValidationError{}

// Validate checks the field values on GetProjectResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetProjectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetProjectRespMultiError,
// or nil if none found.
func (m *GetProjectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetProjectRespValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetProjectRespValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetProjectRespValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetProjectRespMultiError(errors)
	}

	return nil
}

// GetProjectRespMultiError is an error wrapping multiple validation errors
// returned by GetProjectResp.ValidateAll() if the designated constraints
// aren't met.
type GetProjectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectRespMultiError) AllErrors() []error { return m }

// GetProjectRespValidationError is the validation error returned by
// GetProjectResp.Validate if the designated constraints aren't met.
type GetProjectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectRespValidationError) ErrorName() string { return "GetProjectRespValidationError" }

// Error satisfies the builtin error interface
func (e GetProjectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectRespValidationError{}

// Validate checks the field values on ListProjectsReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectsReqMultiError, or nil if none found.
func (m *ListProjectsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListProjectsReqMultiError(errors)
	}

	return nil
}

// ListProjectsReqMultiError is an error wrapping multiple validation errors
// returned by ListProjectsReq.ValidateAll() if the designated constraints
// aren't met.
type ListProjectsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsReqMultiError) AllErrors() []error { return m }

// ListProjectsReqValidationError is the validation error returned by
// ListProjectsReq.Validate if the designated constraints aren't met.
type ListProjectsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsReqValidationError) ErrorName() string { return "ListProjectsReqValidationError" }

// Error satisfies the builtin error interface
func (e ListProjectsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsReqValidationError{}

// Validate checks the field values on ListProjectsResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListProjectsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectsResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectsRespMultiError, or nil if none found.
func (m *ListProjectsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectsRespValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectsRespValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectsRespValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListProjectsRespMultiError(errors)
	}

	return nil
}

// ListProjectsRespMultiError is an error wrapping multiple validation errors
// returned by ListProjectsResp.ValidateAll() if the designated constraints
// aren't met.
type ListProjectsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectsRespMultiError) AllErrors() []error { return m }

// ListProjectsRespValidationError is the validation error returned by
// ListProjectsResp.Validate if the designated constraints aren't met.
type ListProjectsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectsRespValidationError) ErrorName() string { return "ListProjectsRespValidationError" }

// Error satisfies the builtin error interface
func (e ListProjectsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectsRespValidationError{}

// Validate checks the field values on UpdateProjectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectReqMultiError, or nil if none found.
func (m *UpdateProjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Id

	if len(errors) > 0 {
		return UpdateProjectReqMultiError(errors)
	}

	return nil
}

// UpdateProjectReqMultiError is an error wrapping multiple validation errors
// returned by UpdateProjectReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateProjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectReqMultiError) AllErrors() []error { return m }

// UpdateProjectReqValidationError is the validation error returned by
// UpdateProjectReq.Validate if the designated constraints aren't met.
type UpdateProjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectReqValidationError) ErrorName() string { return "UpdateProjectReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateProjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectReqValidationError{}

// Validate checks the field values on UpdateProjectResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateProjectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateProjectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateProjectRespMultiError, or nil if none found.
func (m *UpdateProjectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateProjectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateProjectRespValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateProjectRespValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateProjectRespValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateProjectRespMultiError(errors)
	}

	return nil
}

// UpdateProjectRespMultiError is an error wrapping multiple validation errors
// returned by UpdateProjectResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateProjectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateProjectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateProjectRespMultiError) AllErrors() []error { return m }

// UpdateProjectRespValidationError is the validation error returned by
// UpdateProjectResp.Validate if the designated constraints aren't met.
type UpdateProjectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateProjectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateProjectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateProjectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateProjectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateProjectRespValidationError) ErrorName() string {
	return "UpdateProjectRespValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateProjectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateProjectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateProjectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateProjectRespValidationError{}

// Validate checks the field values on DeleteProjectReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectReqMultiError, or nil if none found.
func (m *DeleteProjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteProjectReqMultiError(errors)
	}

	return nil
}

// DeleteProjectReqMultiError is an error wrapping multiple validation errors
// returned by DeleteProjectReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteProjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectReqMultiError) AllErrors() []error { return m }

// DeleteProjectReqValidationError is the validation error returned by
// DeleteProjectReq.Validate if the designated constraints aren't met.
type DeleteProjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectReqValidationError) ErrorName() string { return "DeleteProjectReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteProjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectReqValidationError{}

// Validate checks the field values on DeleteProjectResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectRespMultiError, or nil if none found.
func (m *DeleteProjectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteProjectRespMultiError(errors)
	}

	return nil
}

// DeleteProjectRespMultiError is an error wrapping multiple validation errors
// returned by DeleteProjectResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteProjectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectRespMultiError) AllErrors() []error { return m }

// DeleteProjectRespValidationError is the validation error returned by
// DeleteProjectResp.Validate if the designated constraints aren't met.
type DeleteProjectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectRespValidationError) ErrorName() string {
	return "DeleteProjectRespValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProjectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectRespValidationError{}

// Validate checks the field values on ApplyRulesStartReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyRulesStartReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRulesStartReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyRulesStartReqMultiError, or nil if none found.
func (m *ApplyRulesStartReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRulesStartReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplyRulesStartReqMultiError(errors)
	}

	return nil
}

// ApplyRulesStartReqMultiError is an error wrapping multiple validation errors
// returned by ApplyRulesStartReq.ValidateAll() if the designated constraints
// aren't met.
type ApplyRulesStartReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRulesStartReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRulesStartReqMultiError) AllErrors() []error { return m }

// ApplyRulesStartReqValidationError is the validation error returned by
// ApplyRulesStartReq.Validate if the designated constraints aren't met.
type ApplyRulesStartReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRulesStartReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRulesStartReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRulesStartReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRulesStartReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRulesStartReqValidationError) ErrorName() string {
	return "ApplyRulesStartReqValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyRulesStartReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRulesStartReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRulesStartReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRulesStartReqValidationError{}

// Validate checks the field values on ApplyRulesStartResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyRulesStartResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRulesStartResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyRulesStartRespMultiError, or nil if none found.
func (m *ApplyRulesStartResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRulesStartResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplyRulesStartRespMultiError(errors)
	}

	return nil
}

// ApplyRulesStartRespMultiError is an error wrapping multiple validation
// errors returned by ApplyRulesStartResp.ValidateAll() if the designated
// constraints aren't met.
type ApplyRulesStartRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRulesStartRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRulesStartRespMultiError) AllErrors() []error { return m }

// ApplyRulesStartRespValidationError is the validation error returned by
// ApplyRulesStartResp.Validate if the designated constraints aren't met.
type ApplyRulesStartRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRulesStartRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRulesStartRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRulesStartRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRulesStartRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRulesStartRespValidationError) ErrorName() string {
	return "ApplyRulesStartRespValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyRulesStartRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRulesStartResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRulesStartRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRulesStartRespValidationError{}

// Validate checks the field values on ApplyRulesCancelReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyRulesCancelReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRulesCancelReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyRulesCancelReqMultiError, or nil if none found.
func (m *ApplyRulesCancelReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRulesCancelReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplyRulesCancelReqMultiError(errors)
	}

	return nil
}

// ApplyRulesCancelReqMultiError is an error wrapping multiple validation
// errors returned by ApplyRulesCancelReq.ValidateAll() if the designated
// constraints aren't met.
type ApplyRulesCancelReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRulesCancelReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRulesCancelReqMultiError) AllErrors() []error { return m }

// ApplyRulesCancelReqValidationError is the validation error returned by
// ApplyRulesCancelReq.Validate if the designated constraints aren't met.
type ApplyRulesCancelReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRulesCancelReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRulesCancelReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRulesCancelReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRulesCancelReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRulesCancelReqValidationError) ErrorName() string {
	return "ApplyRulesCancelReqValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyRulesCancelReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRulesCancelReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRulesCancelReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRulesCancelReqValidationError{}

// Validate checks the field values on ApplyRulesCancelResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyRulesCancelResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRulesCancelResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyRulesCancelRespMultiError, or nil if none found.
func (m *ApplyRulesCancelResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRulesCancelResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplyRulesCancelRespMultiError(errors)
	}

	return nil
}

// ApplyRulesCancelRespMultiError is an error wrapping multiple validation
// errors returned by ApplyRulesCancelResp.ValidateAll() if the designated
// constraints aren't met.
type ApplyRulesCancelRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRulesCancelRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRulesCancelRespMultiError) AllErrors() []error { return m }

// ApplyRulesCancelRespValidationError is the validation error returned by
// ApplyRulesCancelResp.Validate if the designated constraints aren't met.
type ApplyRulesCancelRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRulesCancelRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRulesCancelRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRulesCancelRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRulesCancelRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRulesCancelRespValidationError) ErrorName() string {
	return "ApplyRulesCancelRespValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyRulesCancelRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRulesCancelResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRulesCancelRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRulesCancelRespValidationError{}

// Validate checks the field values on ApplyRulesStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyRulesStatusReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRulesStatusReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyRulesStatusReqMultiError, or nil if none found.
func (m *ApplyRulesStatusReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRulesStatusReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ApplyRulesStatusReqMultiError(errors)
	}

	return nil
}

// ApplyRulesStatusReqMultiError is an error wrapping multiple validation
// errors returned by ApplyRulesStatusReq.ValidateAll() if the designated
// constraints aren't met.
type ApplyRulesStatusReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRulesStatusReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRulesStatusReqMultiError) AllErrors() []error { return m }

// ApplyRulesStatusReqValidationError is the validation error returned by
// ApplyRulesStatusReq.Validate if the designated constraints aren't met.
type ApplyRulesStatusReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRulesStatusReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRulesStatusReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRulesStatusReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRulesStatusReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRulesStatusReqValidationError) ErrorName() string {
	return "ApplyRulesStatusReqValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyRulesStatusReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRulesStatusReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRulesStatusReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRulesStatusReqValidationError{}

// Validate checks the field values on ApplyRulesStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApplyRulesStatusResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyRulesStatusResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApplyRulesStatusRespMultiError, or nil if none found.
func (m *ApplyRulesStatusResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyRulesStatusResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetEstimatedTimeComplete()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyRulesStatusRespValidationError{
					field:  "EstimatedTimeComplete",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyRulesStatusRespValidationError{
					field:  "EstimatedTimeComplete",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedTimeComplete()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyRulesStatusRespValidationError{
				field:  "EstimatedTimeComplete",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PercentageComplete

	// no validation rules for Failed

	// no validation rules for FailureMessage

	// no validation rules for Cancelled

	if len(errors) > 0 {
		return ApplyRulesStatusRespMultiError(errors)
	}

	return nil
}

// ApplyRulesStatusRespMultiError is an error wrapping multiple validation
// errors returned by ApplyRulesStatusResp.ValidateAll() if the designated
// constraints aren't met.
type ApplyRulesStatusRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyRulesStatusRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyRulesStatusRespMultiError) AllErrors() []error { return m }

// ApplyRulesStatusRespValidationError is the validation error returned by
// ApplyRulesStatusResp.Validate if the designated constraints aren't met.
type ApplyRulesStatusRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyRulesStatusRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyRulesStatusRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyRulesStatusRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyRulesStatusRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyRulesStatusRespValidationError) ErrorName() string {
	return "ApplyRulesStatusRespValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyRulesStatusRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyRulesStatusResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyRulesStatusRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyRulesStatusRespValidationError{}

// Validate checks the field values on ListRulesForAllProjectsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRulesForAllProjectsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesForAllProjectsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRulesForAllProjectsReqMultiError, or nil if none found.
func (m *ListRulesForAllProjectsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesForAllProjectsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListRulesForAllProjectsReqMultiError(errors)
	}

	return nil
}

// ListRulesForAllProjectsReqMultiError is an error wrapping multiple
// validation errors returned by ListRulesForAllProjectsReq.ValidateAll() if
// the designated constraints aren't met.
type ListRulesForAllProjectsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesForAllProjectsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesForAllProjectsReqMultiError) AllErrors() []error { return m }

// ListRulesForAllProjectsReqValidationError is the validation error returned
// by ListRulesForAllProjectsReq.Validate if the designated constraints aren't met.
type ListRulesForAllProjectsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesForAllProjectsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesForAllProjectsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesForAllProjectsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesForAllProjectsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesForAllProjectsReqValidationError) ErrorName() string {
	return "ListRulesForAllProjectsReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRulesForAllProjectsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesForAllProjectsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesForAllProjectsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesForAllProjectsReqValidationError{}

// Validate checks the field values on ListRulesForAllProjectsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRulesForAllProjectsResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesForAllProjectsResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRulesForAllProjectsRespMultiError, or nil if none found.
func (m *ListRulesForAllProjectsResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesForAllProjectsResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetProjectRules()))
		i := 0
		for key := range m.GetProjectRules() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetProjectRules()[key]
			_ = val

			// no validation rules for ProjectRules[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ListRulesForAllProjectsRespValidationError{
							field:  fmt.Sprintf("ProjectRules[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ListRulesForAllProjectsRespValidationError{
							field:  fmt.Sprintf("ProjectRules[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ListRulesForAllProjectsRespValidationError{
						field:  fmt.Sprintf("ProjectRules[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ListRulesForAllProjectsRespMultiError(errors)
	}

	return nil
}

// ListRulesForAllProjectsRespMultiError is an error wrapping multiple
// validation errors returned by ListRulesForAllProjectsResp.ValidateAll() if
// the designated constraints aren't met.
type ListRulesForAllProjectsRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesForAllProjectsRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesForAllProjectsRespMultiError) AllErrors() []error { return m }

// ListRulesForAllProjectsRespValidationError is the validation error returned
// by ListRulesForAllProjectsResp.Validate if the designated constraints
// aren't met.
type ListRulesForAllProjectsRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesForAllProjectsRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesForAllProjectsRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesForAllProjectsRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesForAllProjectsRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesForAllProjectsRespValidationError) ErrorName() string {
	return "ListRulesForAllProjectsRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListRulesForAllProjectsRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesForAllProjectsResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesForAllProjectsRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesForAllProjectsRespValidationError{}

// Validate checks the field values on ProjectRules with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectRules) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectRules with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectRulesMultiError, or
// nil if none found.
func (m *ProjectRules) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectRules) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProjectRulesValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProjectRulesValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProjectRulesValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ProjectRulesMultiError(errors)
	}

	return nil
}

// ProjectRulesMultiError is an error wrapping multiple validation errors
// returned by ProjectRules.ValidateAll() if the designated constraints aren't met.
type ProjectRulesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectRulesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectRulesMultiError) AllErrors() []error { return m }

// ProjectRulesValidationError is the validation error returned by
// ProjectRules.Validate if the designated constraints aren't met.
type ProjectRulesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectRulesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectRulesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectRulesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectRulesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectRulesValidationError) ErrorName() string { return "ProjectRulesValidationError" }

// Error satisfies the builtin error interface
func (e ProjectRulesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectRules.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectRulesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectRulesValidationError{}

// Validate checks the field values on ProjectRule with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectRule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectRule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectRuleMultiError, or
// nil if none found.
func (m *ProjectRule) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectRule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectId

	// no validation rules for Name

	// no validation rules for Type

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProjectRuleValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProjectRuleValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProjectRuleValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Deleted

	// no validation rules for Status

	if len(errors) > 0 {
		return ProjectRuleMultiError(errors)
	}

	return nil
}

// ProjectRuleMultiError is an error wrapping multiple validation errors
// returned by ProjectRule.ValidateAll() if the designated constraints aren't met.
type ProjectRuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectRuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectRuleMultiError) AllErrors() []error { return m }

// ProjectRuleValidationError is the validation error returned by
// ProjectRule.Validate if the designated constraints aren't met.
type ProjectRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectRuleValidationError) ErrorName() string { return "ProjectRuleValidationError" }

// Error satisfies the builtin error interface
func (e ProjectRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectRuleValidationError{}

// Validate checks the field values on Condition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Condition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConditionMultiError, or nil
// if none found.
func (m *Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Attribute

	// no validation rules for Operator

	if len(errors) > 0 {
		return ConditionMultiError(errors)
	}

	return nil
}

// ConditionMultiError is an error wrapping multiple validation errors returned
// by Condition.ValidateAll() if the designated constraints aren't met.
type ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionMultiError) AllErrors() []error { return m }

// ConditionValidationError is the validation error returned by
// Condition.Validate if the designated constraints aren't met.
type ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionValidationError) ErrorName() string { return "ConditionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionValidationError{}

// Validate checks the field values on CreateRuleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRuleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRuleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateRuleReqMultiError, or
// nil if none found.
func (m *CreateRuleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRuleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateRuleReq_Id_Pattern.MatchString(m.GetId()) {
		err := CreateRuleReqValidationError{
			field:  "Id",
			reason: "value does not match regex pattern \"^[a-z0-9-_]{1,64}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ProjectId

	// no validation rules for Name

	// no validation rules for Type

	if len(m.GetConditions()) < 1 {
		err := CreateRuleReqValidationError{
			field:  "Conditions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateRuleReqValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateRuleReqValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateRuleReqValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateRuleReqMultiError(errors)
	}

	return nil
}

// CreateRuleReqMultiError is an error wrapping multiple validation errors
// returned by CreateRuleReq.ValidateAll() if the designated constraints
// aren't met.
type CreateRuleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRuleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRuleReqMultiError) AllErrors() []error { return m }

// CreateRuleReqValidationError is the validation error returned by
// CreateRuleReq.Validate if the designated constraints aren't met.
type CreateRuleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRuleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRuleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRuleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRuleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRuleReqValidationError) ErrorName() string { return "CreateRuleReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateRuleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRuleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRuleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRuleReqValidationError{}

var _CreateRuleReq_Id_Pattern = regexp.MustCompile("^[a-z0-9-_]{1,64}$")

// Validate checks the field values on CreateRuleResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRuleResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRuleResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateRuleRespMultiError,
// or nil if none found.
func (m *CreateRuleResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRuleResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRuleRespValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRuleRespValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRuleRespValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRuleRespMultiError(errors)
	}

	return nil
}

// CreateRuleRespMultiError is an error wrapping multiple validation errors
// returned by CreateRuleResp.ValidateAll() if the designated constraints
// aren't met.
type CreateRuleRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRuleRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRuleRespMultiError) AllErrors() []error { return m }

// CreateRuleRespValidationError is the validation error returned by
// CreateRuleResp.Validate if the designated constraints aren't met.
type CreateRuleRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRuleRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRuleRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRuleRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRuleRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRuleRespValidationError) ErrorName() string { return "CreateRuleRespValidationError" }

// Error satisfies the builtin error interface
func (e CreateRuleRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRuleResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRuleRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRuleRespValidationError{}

// Validate checks the field values on UpdateRuleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRuleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRuleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateRuleReqMultiError, or
// nil if none found.
func (m *UpdateRuleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRuleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectId

	// no validation rules for Name

	// no validation rules for Type

	if len(m.GetConditions()) < 1 {
		err := UpdateRuleReqValidationError{
			field:  "Conditions",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetConditions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateRuleReqValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateRuleReqValidationError{
						field:  fmt.Sprintf("Conditions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateRuleReqValidationError{
					field:  fmt.Sprintf("Conditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateRuleReqMultiError(errors)
	}

	return nil
}

// UpdateRuleReqMultiError is an error wrapping multiple validation errors
// returned by UpdateRuleReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateRuleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRuleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRuleReqMultiError) AllErrors() []error { return m }

// UpdateRuleReqValidationError is the validation error returned by
// UpdateRuleReq.Validate if the designated constraints aren't met.
type UpdateRuleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRuleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRuleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRuleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRuleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRuleReqValidationError) ErrorName() string { return "UpdateRuleReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRuleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRuleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRuleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRuleReqValidationError{}

// Validate checks the field values on UpdateRuleResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRuleResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRuleResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateRuleRespMultiError,
// or nil if none found.
func (m *UpdateRuleResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRuleResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateRuleRespValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateRuleRespValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateRuleRespValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateRuleRespMultiError(errors)
	}

	return nil
}

// UpdateRuleRespMultiError is an error wrapping multiple validation errors
// returned by UpdateRuleResp.ValidateAll() if the designated constraints
// aren't met.
type UpdateRuleRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateRuleRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateRuleRespMultiError) AllErrors() []error { return m }

// UpdateRuleRespValidationError is the validation error returned by
// UpdateRuleResp.Validate if the designated constraints aren't met.
type UpdateRuleRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateRuleRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateRuleRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateRuleRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateRuleRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateRuleRespValidationError) ErrorName() string { return "UpdateRuleRespValidationError" }

// Error satisfies the builtin error interface
func (e UpdateRuleRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRuleResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateRuleRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateRuleRespValidationError{}

// Validate checks the field values on GetRuleReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRuleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRuleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRuleReqMultiError, or
// nil if none found.
func (m *GetRuleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRuleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectId

	if len(errors) > 0 {
		return GetRuleReqMultiError(errors)
	}

	return nil
}

// GetRuleReqMultiError is an error wrapping multiple validation errors
// returned by GetRuleReq.ValidateAll() if the designated constraints aren't met.
type GetRuleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRuleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRuleReqMultiError) AllErrors() []error { return m }

// GetRuleReqValidationError is the validation error returned by
// GetRuleReq.Validate if the designated constraints aren't met.
type GetRuleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRuleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRuleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRuleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRuleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRuleReqValidationError) ErrorName() string { return "GetRuleReqValidationError" }

// Error satisfies the builtin error interface
func (e GetRuleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRuleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRuleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRuleReqValidationError{}

// Validate checks the field values on GetRuleResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetRuleResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRuleResp with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetRuleRespMultiError, or
// nil if none found.
func (m *GetRuleResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRuleResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetRuleRespValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetRuleRespValidationError{
					field:  "Rule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetRuleRespValidationError{
				field:  "Rule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetRuleRespMultiError(errors)
	}

	return nil
}

// GetRuleRespMultiError is an error wrapping multiple validation errors
// returned by GetRuleResp.ValidateAll() if the designated constraints aren't met.
type GetRuleRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRuleRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRuleRespMultiError) AllErrors() []error { return m }

// GetRuleRespValidationError is the validation error returned by
// GetRuleResp.Validate if the designated constraints aren't met.
type GetRuleRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRuleRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRuleRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRuleRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRuleRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRuleRespValidationError) ErrorName() string { return "GetRuleRespValidationError" }

// Error satisfies the builtin error interface
func (e GetRuleRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRuleResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRuleRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRuleRespValidationError{}

// Validate checks the field values on ListRulesReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRulesReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRulesReqMultiError, or
// nil if none found.
func (m *ListRulesReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IncludeStaged

	if len(errors) > 0 {
		return ListRulesReqMultiError(errors)
	}

	return nil
}

// ListRulesReqMultiError is an error wrapping multiple validation errors
// returned by ListRulesReq.ValidateAll() if the designated constraints aren't met.
type ListRulesReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesReqMultiError) AllErrors() []error { return m }

// ListRulesReqValidationError is the validation error returned by
// ListRulesReq.Validate if the designated constraints aren't met.
type ListRulesReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesReqValidationError) ErrorName() string { return "ListRulesReqValidationError" }

// Error satisfies the builtin error interface
func (e ListRulesReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesReqValidationError{}

// Validate checks the field values on ListRulesResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRulesResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListRulesRespMultiError, or
// nil if none found.
func (m *ListRulesResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRulesRespValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRulesRespValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRulesRespValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRulesRespMultiError(errors)
	}

	return nil
}

// ListRulesRespMultiError is an error wrapping multiple validation errors
// returned by ListRulesResp.ValidateAll() if the designated constraints
// aren't met.
type ListRulesRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesRespMultiError) AllErrors() []error { return m }

// ListRulesRespValidationError is the validation error returned by
// ListRulesResp.Validate if the designated constraints aren't met.
type ListRulesRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesRespValidationError) ErrorName() string { return "ListRulesRespValidationError" }

// Error satisfies the builtin error interface
func (e ListRulesRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesRespValidationError{}

// Validate checks the field values on ListRulesForProjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRulesForProjectReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesForProjectReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRulesForProjectReqMultiError, or nil if none found.
func (m *ListRulesForProjectReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesForProjectReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ListRulesForProjectReqMultiError(errors)
	}

	return nil
}

// ListRulesForProjectReqMultiError is an error wrapping multiple validation
// errors returned by ListRulesForProjectReq.ValidateAll() if the designated
// constraints aren't met.
type ListRulesForProjectReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesForProjectReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesForProjectReqMultiError) AllErrors() []error { return m }

// ListRulesForProjectReqValidationError is the validation error returned by
// ListRulesForProjectReq.Validate if the designated constraints aren't met.
type ListRulesForProjectReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesForProjectReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesForProjectReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesForProjectReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesForProjectReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesForProjectReqValidationError) ErrorName() string {
	return "ListRulesForProjectReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListRulesForProjectReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesForProjectReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesForProjectReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesForProjectReqValidationError{}

// Validate checks the field values on ListRulesForProjectResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRulesForProjectResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRulesForProjectResp with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRulesForProjectRespMultiError, or nil if none found.
func (m *ListRulesForProjectResp) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRulesForProjectResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRules() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRulesForProjectRespValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRulesForProjectRespValidationError{
						field:  fmt.Sprintf("Rules[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRulesForProjectRespValidationError{
					field:  fmt.Sprintf("Rules[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if len(errors) > 0 {
		return ListRulesForProjectRespMultiError(errors)
	}

	return nil
}

// ListRulesForProjectRespMultiError is an error wrapping multiple validation
// errors returned by ListRulesForProjectResp.ValidateAll() if the designated
// constraints aren't met.
type ListRulesForProjectRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRulesForProjectRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRulesForProjectRespMultiError) AllErrors() []error { return m }

// ListRulesForProjectRespValidationError is the validation error returned by
// ListRulesForProjectResp.Validate if the designated constraints aren't met.
type ListRulesForProjectRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRulesForProjectRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRulesForProjectRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRulesForProjectRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRulesForProjectRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRulesForProjectRespValidationError) ErrorName() string {
	return "ListRulesForProjectRespValidationError"
}

// Error satisfies the builtin error interface
func (e ListRulesForProjectRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRulesForProjectResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRulesForProjectRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRulesForProjectRespValidationError{}

// Validate checks the field values on DeleteRuleReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRuleReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRuleReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteRuleReqMultiError, or
// nil if none found.
func (m *DeleteRuleReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRuleReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ProjectId

	if len(errors) > 0 {
		return DeleteRuleReqMultiError(errors)
	}

	return nil
}

// DeleteRuleReqMultiError is an error wrapping multiple validation errors
// returned by DeleteRuleReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteRuleReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRuleReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRuleReqMultiError) AllErrors() []error { return m }

// DeleteRuleReqValidationError is the validation error returned by
// DeleteRuleReq.Validate if the designated constraints aren't met.
type DeleteRuleReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRuleReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRuleReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRuleReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRuleReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRuleReqValidationError) ErrorName() string { return "DeleteRuleReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRuleReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRuleReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRuleReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRuleReqValidationError{}

// Validate checks the field values on DeleteRuleResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRuleResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRuleResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteRuleRespMultiError,
// or nil if none found.
func (m *DeleteRuleResp) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRuleResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteRuleRespMultiError(errors)
	}

	return nil
}

// DeleteRuleRespMultiError is an error wrapping multiple validation errors
// returned by DeleteRuleResp.ValidateAll() if the designated constraints
// aren't met.
type DeleteRuleRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRuleRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRuleRespMultiError) AllErrors() []error { return m }

// DeleteRuleRespValidationError is the validation error returned by
// DeleteRuleResp.Validate if the designated constraints aren't met.
type DeleteRuleRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRuleRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRuleRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRuleRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRuleRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRuleRespValidationError) ErrorName() string { return "DeleteRuleRespValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRuleRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRuleResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRuleRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRuleRespValidationError{}
